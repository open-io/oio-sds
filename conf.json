{
	"meta2": {
		"code": "meta2_variables.c",
		"header": "meta2_variables.h",
		"variables": [
			{ "type": "int64", "name": "meta2_container_max_contents",
				"key": "meta2.container.max_contents",
				"descr": "Maximum number of contents in each container.",
				"def": 0, "min": 0, "max": "max" },

			{ "type": "int64", "name": "meta2_max_versions",
				"key": "meta2.max_versions",
				"descr": "How many versions for a single alias.",
				"def": 1, "min": -1, "max": "max" },

			{ "type": "int64", "name": "meta2_container_max_size",
				"key": "meta2.container.max_size",
				"descr": "How many bytes may be stored in each container.",
				"def": 0, "min": 0, "max": "max" },

			{ "type": "epoch", "name": "meta2_retention_period",
				"key": "meta2.retention_period",
				"descr": "How long should deleted content be kept.",
				"def": "7d", "min": "1s", "max": "30d" },

			{ "type": "uint", "name": "meta2_batch_maxlen",
				"key": "meta2.batch.maxlen",
				"descr": "When listing a container, limits the number of items to that value.",
				"def": "1k", "min": 1, "max": "100k" },

			{ "type": "epoch", "name": "meta2_reload_lb_period",
				"key": "meta2.reload.lb.period",
				"descr": "Sets the period of the periodical reloading of the load-balancing state, in the current meta2 service.",
				"def": "10s", "min": "1s", "max": "1h" },

			{ "type": "epoch", "name": "meta2_reload_nsinfo_period",
				"key": "meta2.reload.nsinfo.period",
				"descr": "Sets the period of the periodical reloading of the namespace configuration, in the current meta2 service.",
				"def": "5s", "min": "1s", "max": "1h" },

			{ "type": "bool", "name": "meta2_flag_precheck_on_generate",
				"key": "meta2.generate.precheck",
				"descr": "Should the meta2 check the container state (quota, etc) before generating chunks.",
				"def": true }
		]
	},
	"rawx": {
		"code": "rawx_variables.c",
		"header": "rawx_variables.h",
		"variables": [
			{ "type": "bool", "name": "oio_rawx_events",
				"key": "rawx.events_allowed",
				"def": true,
				"descr": "" }
		]
	},
	"events": {
		"code": "events_variables.c",
		"header": "events_variables.h",
		"variables": [
			{ "type": "monotonic", "name": "oio_events_common_buffer_delay",
				"key": "events.common.pending.delay",
				"def": "5s", "min": "1ms", "max": "1h",
				"descr": "Sets the buffering delay of the events emitted by the application" },

			{ "type": "uint32", "name": "oio_events_common_max_pending",
				"key": "events.common.pending.max",
				"descr": "Sets the maximum number of pending events, not received yet by the endpoint",
				"def": "1000", "min": 1, "max": "1Mi" },

			{ "type": "uint", "name": "oio_events_zmq_max_recv",
				"key": "events.zmq.max_recv",
				"descr": "Sets the maximum number of ACK managed by the ZMQ notification client",
				"def": "32", "min": 1, "max": "1<<31 - 1" },

			{ "type": "monotonic", "name": "oio_events_beanstalkd_timeout",
				"key": "events.beanstalkd.timeout",
				"descr": "Set the interval between each check of the beanstalkd availability. Set to 0 to never check.",
				"def": "4s", "min": "100ms", "max": "90s" },

			{ "type": "monotonic", "name": "oio_events_beanstalkd_check_period",
				"key": "events.beanstalkd.check_period",
				"descr": "Set the interval between each check of the beanstalkd availability. Set to 0 to never check.",
				"def": "0", "min": "0", "max": "1d" },

			{ "type": "int64", "name": "oio_events_beanstalkd_check_level_deny",
				"key": "events.beanstalkd.check_level_deny",
				"descr": "Set the maximum number of items in beanstalkd before considering it full",
				"def": "500ki", "min": "0", "max": "max" },

			{ "type": "int64", "name": "oio_events_beanstalkd_check_level_alert",
				"key": "events.beanstalkd.check_level_alert",
				"descr": "Set a threshold for the number of items in the beanstalkd, so that the service will alert past that value. Set to 0 for no alert sent.",
				"def": "0", "min": "0", "max": "max" },

			{ "type": "uint", "name": "oio_events_beanstalkd_default_prio",
				"key": "events.beanstalkd.prio",
				"descr": "Sets the priority of each notification sent to the BEANSTALK endpoint",
				"def": "1 << 32 - 1", "min": 0, "max": "1 << 32 - 1" },

			{ "type": "epoch", "name": "oio_events_beanstalkd_default_delay",
				"key": "events.beanstalkd.delay",
				"descr": "Sets the delay on each notification sent to the BEANSTALK endpoint",
				"def": 0, "min": 0, "max": "1d" },

			{ "type": "epoch", "name": "oio_events_beanstalkd_default_ttr",
				"key": "events.beanstalkd.ttr",
				"descr": "Sets the TTR (time to run) allowed on the treatment of the notification sent to the beanstalkd",
				"def": 120, "min": 0, "max": 86400 }
		]
	},
	"resolver": {
		"code": "resolver_variables.c",
		"header": "resolver_variables.h",
		"variables": [
			{ "type": "bool", "name": "oio_resolver_srv_shuffle",
				"key": "core.resolver.srv_shuffle",
				"descr": "",
				"def": true },

			{ "type": "bool", "name": "oio_resolver_dir_shuffle",
				"key": "core.resolver.dir_shuffle",
				"descr": "",
				"def": true },

			{ "type": "bool", "name": "oio_resolver_cache_enabled",
				"key": "resolver.cache.enabled",
				"descr": "Allows the resolver instances to cache entries",
				"def": true },

			{ "type": "monotonic", "name": "oio_resolver_m0cs_default_ttl",
				"key": "resolver.cache.csm0.ttl.default",
				"descr": "In any service resolver instantiated, sets the default TTL on the entries related to meta0 (meta1 addresses) and conscience (meta0 address)",
				"def": 0, "min": 0, "max": "max" },

			{ "type": "uint", "name": "oio_resolver_m0cs_default_max",
				"key": "resolver.cache.csm0.max.default",
				"descr": "In any service resolver instantiated, sets the maximum number of entries related to meta0 (meta1 addresses) and conscience (meta0 address)",
				"def": 0, "min": 0, "max": "max" },

			{ "type": "monotonic", "name": "oio_resolver_srv_default_ttl",
				"key": "resolver.cache.srv.ttl.default",
				"descr": "In any service resolver instantiated, sets the default TTL on the meta1 entries (data-bound services)",
				"def": 0, "min": 0, "max": "max" },

			{ "type": "uint", "name": "oio_resolver_srv_default_max",
				"key": "resolver.cache.srv.max.default",
				"descr": "In any service resolver instantiated, sets the maximum number of meta1 entries (data-bound services)",
				"def": 0, "min": 0, "max": "max" }
		]
	},
	"metautils": {
		"license": "lgpl",
		"code": "common_variables.c",
		"header": "common_variables.h",
		"variables": [
			{ "type": "uint", "name": "oio_ns_flat_bits",
				"key": "ns.flat_bits",
				"descr": "Default number of bits with flat-NS computation.",
				"def": 17, "min": 0, "max": 64 },

			{ "type": "int64", "name": "oio_ns_chunk_size",
				"key": "ns.chunk_size",
				"descr": "Default chunk size for the given namespace.",
				"def": "10Mi", "min": 1, "max": "max" },

			{ "type": "string", "name": "oio_ns_service_update_policy",
				"key": "ns.service_update_policy",
				"limit": 1024,
				"def": "meta2=KEEP|3|1;sqlx=KEEP|1|1|;rdir=KEEP|1|1|user_is_a_service=rawx",
				"descr": "" },

			{ "type": "string", "name": "oio_ns_storage_policy",
				"key": "ns.storage_policy",
				"limit": 128,
				"def": "NONE",
				"descr": "" },

			{ "type": "bool", "name": "oio_ns_master",
				"key": "ns.master",
				"def": true,
				"descr": "" },

			{ "type": "bool", "name": "oio_ns_mode_worm",
				"key": "ns.worm",
				"def": false,
				"descr": "Is the NS in a WORM (for Write Once, Read Many -- but never delete)." },

			{ "type": "monotonic", "name": "main_log_level_reset_delay",
				"key": "common.verbosity.reset_delay",
				"def": "5m", "min": "1s", "max": "1h",
				"descr": "Tells how long the verbosity remains higher before being reset to the default, after a SIGUSR1 has been received." },

			{ "type": "float", "name": "oio_m1_client_timeout_common",
				"key": "meta1.outgoing.timeout.common.req",
				"descr": "Sets the timeout to the set of (quick) RPC that query a meta1 service",
				"def": 10.0, "min": 0.01, "max": 60.0 },

			{ "type": "float", "name": "oio_m0_client_timeout_common",
				"key": "meta0.outgoing.timeout.common.req",
				"descr": "Sets the timeout to the set of (quick) RPC that query a meta0 service",
				"def": 10.0, "min": 0.01, "max": 60.0 },

			{ "type": "bool", "name": "oio_log_outgoing",
				"key": "server.log_outgoing",
				"def": false,
				"descr": "" },

			{ "type": "bool", "name": "oio_socket_linger_onoff",
				"key": "socket.linger.enabled",
				"def": false,
				"descr": "Set to TRUE to allow the LINGER behavior of TCP sockets, as a default. The connections then end with a normal FIN packet, and go in the TIME_WAIT state for a given delay. Setting to FALSE causes connections to be closed with a RST packet, thus avoiding a lot of TCP sockets in the TIME_WAIT state." },

			{ "type": "epoch", "name": "oio_socket_linger_delay",
				"key": "socket.linger.delay",
				"def": "1s", "min": 0, "max": 60,
				"descr": "When socket.linger.enabled is set to TRUE, socket.linger.delay tells how much the socket remains in the TIME_WAIT state after the close() has been called." },

			{ "type": "bool", "name": "oio_socket_quickack",
				"key": "socket.quickack.enabled",
				"def": true,
				"descr": "Should the sockets opened by the application receive the TCP_QUICKACK flag." },

			{ "type": "bool", "name": "oio_socket_nodelay",
				"key": "socket.nodelay.enabled",
				"def": true,
				"descr": "Should the socket to meta~ services receive the TCP_NODELAY flag. When TRUE, it disables the Naggle's algorithm." },

			{ "type": "bool", "name": "oio_socket_fastopen",
				"key": "socket.fastopen.enabled",
				"def": true,
				"descr": "Should the socket to meta~ services use TCP_FASTOPEN flag." },

			{ "type": "int32", "name": "oio_client_fake_timeout_threshold",
				"key": "enbug.client.fake_timeout.threshold",
				"def": "10",
				"descr": "Set the probability of fake timeout failures, in any client RPC to a 'meta' service" },

			{ "type": "bool", "name": "oio_client_cache_errors",
				"key": "client.errors_cache.enabled",
				"def": false,
				"descr": "Should the client feed a cache with the network errors it encounters, and should those errors be used to prevent RPC to be performed toward 'too-faulty' peers." },

			{ "type": "uint64", "name": "oio_client_cache_errors_max",
				"key": "client.errors_cache.max",
				"def": "15", "min": 1, "max": "4Gi",
				"descr": "Sets the number of faults (on the period given by client.errors_cache.period) beyond which a peer is considered as too faulty to try a new RPC." },

			{ "type": "epoch", "name": "oio_client_cache_errors_period",
				"key": "client.errors_cache.period",
				"def": "15s", "min": "1s", "max": "1h",
				"descr": "Sets the size of the time window used to count the number of network errors." },


			{ "type": "float", "name": "oio_client_timeout_single",
				"key": "gridd.timeout.single.common",
				"def": 30.0, "min": 0.01, "max": 120.0,
				"descr": "Sets the default timeout for unitary (request/response) RPC, without considering the possible redirection." },

			{ "type": "float", "name": "oio_client_timeout_whole",
				"key": "gridd.timeout.whole.common",
				"def": 30.0, "min": 0.01, "max": 120.0,
				"descr": "Sets the global timeout of a RPC to a 'meta' service, considering all the possible redirections." },

			{ "type": "float", "name": "oio_client_timeout_connect",
				"key": "gridd.timeout.connect.common",
				"def": 2.0, "min": 0.01, "max": 120.0,
				"descr": "Sets the connection timeout, involved in any RPC to a 'meta' service." }
		]
	},
	"sqliterepo_remote": {
		"license": "lgpl",
		"code": "sqliterepo_remote_variables.c",
		"header": "sqliterepo_remote_variables.h",
		"variables": [
			{ "type": "float", "name": "oio_election_use_timeout_cnx",
				"key": "sqliterepo.outgoing.timeout.cnx.use",
				"descr": "Sets the connection timeout when ping'ing a peer database. Keep it small. Only used when UDP is disabled.",
				"def": 0.25, "min": 0.01, "max": 30.0 },

			{ "type": "float", "name": "oio_election_use_timeout_req",
				"key": "sqliterepo.outgoing.timeout.req.use",
				"descr": "Sets the global timeout when ping'ing a peer database. Keep it small.",
				"def": 1.0, "min": 0.01, "max": 30.0 },

			{ "type": "float", "name": "oio_election_getvers_timeout_cnx",
				"key": "sqliterepo.outgoing.timeout.cnx.getvers",
				"descr": "Sets the connection timeout when exchanging versions between databases replicas.",
				"def": 0.5, "min": 0.01, "max": 30.0 },

			{ "type": "float", "name": "oio_election_getvers_timeout_req",
				"key": "sqliterepo.outgoing.timeout.req.getvers",
				"descr": "Sets the global timeout when performing a version exchange RPC. Keep it rather small, to let election quickly fail on network troubles. Only used when UDP is disabled.",
				"def": 2.0, "min": 0.01, "max": 30.0 },

			{ "type": "float", "name": "oio_election_replicate_timeout_cnx",
				"key": "sqliterepo.outgoing.timeout.cnx.replicate",
				"descr": "Sets the connection timeout sending a replication request.",
				"def": 1.0, "min": 0.01, "max": 30.0 },

			{ "type": "float", "name": "oio_election_replicate_timeout_req",
				"key": "sqliterepo.outgoing.timeout.req.replicate",
				"descr": "Sets the global timeout when sending a replication RPC, from the current MASTER to a SLAVE",
				"def": 10.0, "min": 0.01, "max": 30.0 },

			{ "type": "float", "name": "oio_election_resync_timeout_cnx",
				"key": "sqliterepo.outgoing.timeout.cnx.resync",
				"descr": "Set the connection timeout during RPC to ask for a SLAVE database to be resync'ed to its MASTER",
				"def": 1.0, "min": 0.01, "max": 30.0 },

			{ "type": "float", "name": "oio_election_resync_timeout_req",
				"key": "sqliterepo.outgoing.timeout.req.resync",
				"descr": "Sets the global timeout of a RESYNC request sent to a 'meta' service. Sent to a SLAVE DB, the RESYNC operation involves a RPC from the SLAVE to the MASTER, then a DB dump on the MASTER and restoration on the SLAVE. Thus that operation might be rather long, due to the possibility of network/disk latency/bandwidth, etc.",
				"def": 30.0, "min": 0.01, "max": 60.0 }
		]
	},
	"sqliterepo": {
		"license": "lgpl",
		"code": "sqliterepo_variables.c",
		"header": "sqliterepo_variables.h",
		"variables": [
			{ "type": "uint", "name": "sqliterepo_zk_mux_factor",
				"key": "sqliterepo.zk.mux_factor",
				"descr": "For testing purposes. The value simulates ZK sharding on different connection to the same cluster.",
				"def": 1, "min": 1, "max": 64},

			{ "type": "bool", "name": "sqliterepo_zk_shuffle",
				"key": "sqliterepo.zk.shuffle",
				"descr": "Should the synchronism mechanism shuffle the set of URL in the ZK connection string? Set to yes as an attempt to a better balancing of the connections to the nodes of the ZK cluster.",
				"def": true},

			{ "type": "monotonic", "name": "oio_election_period_cond_wait",
				"key": "sqliterepo.election.wait.quantum",
				"descr": "In the current sqliterepo repository, while loop-waiting for a final election status to be reached, this value sets the unit amount of time each unit can wait on the lock. Keep this value rather small to avoid waiting for too long, but not too small to avoid dumping CPU cycles in active waiting.",
				"def": "1s", "min": "1ms", "max": "1h" },

			{ "type": "monotonic", "name": "oio_election_delay_wait",
				"key": "sqliterepo.election.wait.delay",
				"descr": "In the current sqliterepo repository, sets the maximum amount of time a worker thread is allowed to wait for an election to get its final status.",
				"def": "5s", "min": "1ms", "max": "1h" },

			{ "type": "bool", "name": "oio_election_enable_nowait_pending",
				"key": "sqliterepo.election.nowait.enable",
				"descr": "Check of the election is pending since too long. If it is, don't way for it.",
				"def": false },

			{ "type": "monotonic", "name": "oio_election_delay_nowait_pending",
				"key": "sqliterepo.election.nowait.after",
				"descr": "In the current sqliterepo repository, sets the amount of time spent in an election resolution that will make a worker thread won't wait at all and consider that election is stalled.",
				"def": "15m", "min": "1ms", "max": "max" },

			{ "type": "monotonic", "name": "oio_election_delay_expire_NONE",
				"key": "sqliterepo.election.delay.expire_none",
				"descr": "In the current sqliterepo repository, sets the amount of time an election without status will be forgotten ",
				"def": "5m", "min": "1s", "max": "1d" },

			{ "type": "monotonic", "name": "oio_election_delay_expire_SLAVE",
				"key": "sqliterepo.election.delay.expire_slave",
				"descr": "In the current sqliterepo repository, sets the amount of time after which a SLAVE election will drop its status and return to the NONE status. This helps recycling established-but-unused elections, and save Zookeeper nodes.",
				"def": "15m", "min": "1s", "max": "7d" },

			{ "type": "monotonic", "name": "oio_election_delay_ping_final",
				"key": "sqliterepo.election.delay.ping_final",
				"descr": "In the current sqliterepo repository, sets the average amount of time after which a PING will be sent for an established election. This is an average, in fact some jitter is introduced to avoid resonance effects on large-scale platforms. Should be greater than sqliterepo.election.delay.expire_slave if you want the slaves to actually expire.",
				"def": "30m", "min": "1ms", "max": "1d" },

			{ "type": "monotonic", "name": "oio_election_delay_expire_MASTER",
				"key": "sqliterepo.election.delay.expire_master",
				"descr": "In the current sqliterepo repository, sets the amount of time after which a MASTER election will drop its status and return to the NONE status. This helps recycling established-but-unused elections, and save Zookeeper nodes. Keep this value between sqliterepo.election.delay.expire_slave and sqliterepo.election.delay.ping_final if you want the election to never expire.",
				"def": "25m", "min": "1ms", "max": "7d" },

			{ "type": "monotonic", "name": "oio_election_delay_retry_FAILED",
				"key": "sqliterepo.election.delay.retry_failed",
				"descr": "In the current sqliterepo repository, sets the amount of time after which a failed election leaves its FAILED status and returns to the NONE status.",
				"def": "2s", "min": "1ms", "max": "7d" },

			{ "type": "uint", "name": "_page_size",
				"key": "sqliterepo.page_size",
				"descr": "In the current sqliterepo repository, sets the page size of all the databases used. This value only has effects on databases created with that value.",
				"def": 4096, "min": 512, "max": "1024 * 1024" },

			{ "type": "int32", "name": "oio_sqlx_request_failure_threshold",
				"key": "enbug.sqliterepo.client.failure.threshold",
				"descr": "In testing situations, sets the average ratio of requests failing for a fake reason (from the peer). This helps testing the retrial mechanisms.",
				"def": 10, "min": 0, "max": 100 },

			{ "type": "monotonic", "name": "oio_sqlx_timeout_check_period",
				"key": "enbug.sqliterepo.client.timeout.period",
				"descr": "In testing situations, sets the average ratio of requests failing for a fake reason (connection timeout). This helps testing the retrial mechanisms and the behavior under strong network split-brain.",
				"def": "1s", "min": "1ms", "max": "1d" },

			{ "type": "monotonic", "name": "oio_sqlx_timeout_check_max",
				"key": "sqliterepo.client.timeout.alert_if_longer",
				"descr": "In the current sqliterepo repository, sets the maximum amount of time a periodical task may take, while checking for the timeouts on the outbound connections.",
				"def": "5s", "min": "1ms", "max": "1h" },

			{ "type": "uint", "name": "sqliterepo_election_task_EXIT_period",
				"key": "sqliterepo.election.task.exit.period",
				"descr": "In jiffies, how often the removal of expired NONE elections happens",
				"def": "5", "min": 0, "max": "86400" },

			{ "type": "uint", "name": "sqliterepo_election_task_TIMER_period",
				"key": "sqliterepo.election.task.timer.period",
				"descr": "In jiffies, how often the elections waiting for timers are fired",
				"def": "1", "min": 0, "max": "86400" },

			{ "type": "uint", "name": "sqliterepo_election_task_PING_period",
				"key": "sqliterepo.election.task.ping.period",
				"descr": "In jiffies, how often a PING may be triggered for elections in a final state.",
				"def": "15", "min": 0, "max": "86400" },

			{ "type": "monotonic", "name": "sqliterepo_election_task_EXIT_alert",
				"key": "sqliterepo.election.task.exit.alert",
				"descr": "When NONE elections are expired, report a warning if the background task holds the lock longer than this value.",
				"def": "200ms", "min": 0, "max": "max" },

			{ "type": "monotonic", "name": "sqliterepo_election_task_TIMER_alert",
				"key": "sqliterepo.election.task.timer.alert",
				"descr": "When timers are raised on elections, report a warning if the background task holds the lock longer than this value.",
				"def": "200ms", "min": 0, "max": "max" },

			{ "type": "monotonic", "name": "sqliterepo_election_task_PING_alert",
				"key": "sqliterepo.election.task.ping.alert",
				"descr": "When pings are sent from election in a final state, report a warning if the background task holds the lock longer than this value.",
				"def": "200ms", "min": 0, "max": "max" },

			{ "type": "uint", "name": "disconnection_rrd_window",
			   "key": "sqliterepo.zk.rrd.window",
				"descr": "Sets the time window to remember the reconnection events, on a ZK connection.",
			   "def": 30, "min": 1, "max": 4095 },

			{ "type": "uint", "name": "disconnection_threshold",
				"key": "sqliterepo.zk.rrd.threshold",
				"descr": "Sets the maximum number of reconnections to the ZK that remains acceptable. Beyond that limit, we consider that the current service has been disconnected, and that it has lost all its nodes.",
				"def": 5, "min": 1, "max": "1 << 32 - 1" },

			{ "type": "int32", "name": "oio_sync_failure_threshold_action",
				"key": "enbug.sqliterepo.synchro.failure",
				"descr": "Fake error rate on synchronism RPC (a.k.a. ZK) ",
				"def": 10, "min": 0, "max": 100 },

			{ "type": "bool", "name": "_cache_fail_on_heavy_load",
				"key": "sqliterepo.cache.heavyload.fail",
				"descr": "Triggers an error when a thread waits for an overloaded database.",
				"def": false},

			{ "type": "bool", "name": "_cache_alert_on_heavy_load",
				"key": "sqliterepo.cache.heavyload.alert",
				"descr": "Triggers an alert when a thread tries to wait for an overloaded database.",
				"def": true },

			{ "type": "uint32", "name": "_cache_max_waiting",
				"key": "sqliterepo.cache.waiting.max",
				"descr": "Sets how many threads can wait on a single database. All the additional waiters will be denied with any wait attempt.",
				"def": 16, "min": 0, "max": "1<<32 - 1" },

			{ "type": "monotonic", "name": "_cache_timeout_open",
				"key": "sqliterepo.cache.timeout.open",
				"descr": "Sets how long a worker thread accepts for a DB to become available.",
				"def": "20s", "min": "1ms", "max": "1d" },

			{ "type": "monotonic", "name": "_cache_period_cond_wait",
				"key": "sqliterepo.cache.timeout.lock",
				"descr": "Sets how long we (unit)wait on the lock around the databases. Keep it small.",
				"def": "1s", "min": "1ms", "max": "1h" },

			{ "type": "uint32", "name": "_cache_heat_threshold",
				"key": "sqliterepo.cache.heat_threshold",
				"descr": "Sets the heat value below which a database is considered hot",
				"def": 1, "min": 1, "max": "1 << 32 - 1" },

			{ "type": "monotonic", "name": "_cache_grace_delay_cool",
				"key": "sqliterepo.cache.ttl.cool",
				"descr": "Sets the period after the return to the IDLE/COLD state, during which the recycling is forbidden. 0 means the base won't be decached.",
				"def": "1ms", "min": "0", "max": "1d" },

			{ "type": "monotonic", "name": "_cache_grace_delay_hot",
				"key": "sqliterepo.cache.ttl.hot",
				"descr": "Sets the period after the return to the IDLE/HOT state, during which the recycling is forbidden. 0 means the base won't be decached.",
				"def": "1ms", "min": "0", "max": "1d" },

			{ "type": "uint", "name": "sqliterepo_release_size",
				"key": "sqliterepo.release_size",
				"descr": "Sets how many bytes bytes are released when the LEAN request is received by the current 'meta' service.",
				"def": "64Mi", "min": 1, "max": "1<<32 - 1" },

			{ "type": "monotonic", "name": "sqliterepo_zk_timeout",
				"key": "sqliterepo.zk.timeout",
				"descr": "Sets the timeout of the zookeeper handle (in the meaning of the zookeeper client library)",
				"def": "10s", "min": "1ms", "max": "1h" },

			{ "type": "uint", "name": "sqliterepo_repo_max_bases_hard",
				"key": "sqliterepo.repo.hard_max",
				"descr": "Sets how many databases can be kept simultaneously open (in use or idle) in the current service. If defined to 0, it is set to 30% of available file descriptors.",
				"def": "0", "min": "0", "max": "128ki" },

			{ "type": "uint", "name": "sqliterepo_repo_max_bases_soft",
				"key": "sqliterepo.repo.soft_max",
				"descr": "Sets how many databases can be in use at the same moment in the current service. If defined to 0, it is set to sqliterepo.repo.hard_max.",
				"def": "0", "min": "0", "max": "128ki" },

			{ "type": "monotonic", "name": "sqliterepo_getvers_backoff",
				"key": "sqliterepo.repo.getvers_backoff",
				"descr": ".",
				"def": "2s", "min": "10ms", "max": "1m" },

			{ "type": "uint", "name": "sqliterepo_getvers_max_retries",
				"key": "sqliterepo.repo.getvers_max_retries",
				"descr": "Sets how many versions exchanges are allowed during the journey in the election FSM.",
				"def": 2, "min": 1, "max": "64" },

			{ "type": "uint", "name": "sqliterepo_fd_max_active",
				"key": "sqliterepo.repo.fd_max_active",
				"descr": "Maximum number of simultaneous outgoing connections. Set to 0 for an automatic detection (30% of available file descriptors).",
				"def": 0, "min": 0, "max": "64ki" },

			{ "type": "uint", "name": "sqliterepo_fd_min_active",
				"key": "sqliterepo.repo.fd_min_active",
				"descr": "Minimum number of simultaneous outgoing connections.",
				"def": 32, "min": 0, "max": "64ki" }
		]
	},
	"rdir": {
		"code": "rdir_variables.c",
		"header": "rdir_variables.h",
		"variables": [
			{ "type": "uint", "name": "rdir_fd_reserve",
				"key": "rdir.fd_reserve",
				"descr": "Only effective when `server.fd_max_passive` is set to 0 (autodetection). When deducing the maximum number of incoming connections, the rdir reserves that amount of file descritors to reach the database shards, and allocates what remains to the network.",
				"def": 128, "min": 64, "max": "1024" }
		]
	},
	"server": {
		"license": "lgpl",
		"code": "server_variables.c",
		"header": "server_variables.h",
		"variables": [
			{ "type": "uint", "name": "server_fd_max_passive",
				"key": "server.fd_max_passive",
				"descr": "Maximum number of simultaneous incoming connections. Set to 0 for an automatic detection (40% of available file descriptors).",
				"def": 0, "min": 0, "max": "64ki" },

			{ "type": "bool", "name": "oio_udp_allowed",
				"key": "udp_allowed",
				"def": false,
				"descr": "Allow the sqlx client DB_USE RPC to be sent via UDP instead of the default TCP channel."},

			{ "type": "epoch", "name": "oio_sqlx_lb_refresh_period",
				"key": "sqlx.lb.refresh_period",
				"descr": "In the current sqlx-based service, tells the period (in seconds) at which the service will refresh its load-balancing information.",
				"def": "1", "min": 1, "max": "60s" },

			{ "type": "uint", "name": "server_event_batch_size",
				"key": "server.batch.events",
				"descr": "In the network core of a server, how many events do you manage in each call to epoll_wait(). Set to a low value to quickly react on new connections, or to an high value to rather treat established connections. The value is bound to a stack-allocated buffer, keep it rather small.",
				"def": 128, "min": 1, "max": "4ki" },

			{ "type": "uint", "name": "server_accept_batch_size",
				"key": "server.batch.accept",
				"descr": "In the network core, when the server socket wakes the call to epoll_wait(), that value sets the number of subsequent calls to accept(). Setting it to a low value allows to quickly switch to other events (established connection) and can lead to a starvation on the new connections. Setting to a high value might spend too much time in accepting and ease denials of service (with established but idle cnx).",
				"def": 64, "min": 1, "max": "4ki" },

			{ "type": "monotonic", "name": "sqliterepo_server_exit_ttl",
				"key": "sqliterepo.service.exit_ttl",
				"descr": ".",
				"def": "10s", "min": "1ms", "max": "1h" },

			{ "type": "int", "name": "server_threadpool_max_unused",
				"key": "server.pool.max_unused",
				"descr": "In the current server, sets how many threads may remain unused. This value is, in the GLib, common to all the threadpools.",
				"def": "20", "min":0, "max":"1<<31 -1" },

			{ "type": "monotonic", "name": "server_threadpool_max_idle",
				"key": "server.pool.max_idle",
				"descr": "In the current server, sets how long a thread can remain unused before being considered as idle (and thus be stopped)",
				"def": "30s", "min": 1, "max": "1h" },

			{ "type": "int", "name": "server_threadpool_max_stat",
				"key": "server.pool.max_stat",
				"descr": "In the current server, sets how many threads are allowed to the stats server. Keep this value really small, 1 should be enough for most usages, and consider increasing it if you have clues that the management of internal metrics is the bottleneck. Set to 0 for no limit.",
				"def": "1", "min": 0, "max": "1 << 31 - 1" },

			{ "type": "int", "name": "server_threadpool_max_tcp",
				"key": "server.pool.max_tcp",
				"descr": "In the current server, sets the maximum number of threads for the pool responsible for the TCP connections (threading model is one thread per request being managed, and one request at once per TCP connection). Set to 0 for no limit.",
				"def": "0", "min": 0, "max": "1 << 31 - 1" },

			{ "type": "int", "name": "server_threadpool_max_udp",
				"key": "server.pool.max_udp",
				"descr": "In the current server, sets the maximum number of threads for pool responsible for the UDP messages handling. UDP is only used for quick synchronisation messages during MASTER elections. Set ot 0 for no limit.",
				"def": 4, "min": 0, "max": "1 << 31 - 1" },

			{ "type": "monotonic", "name": "server_cnx_ttl_never",
				"key": "server.cnx.timeout.never",
				"descr": "In the current server, sets the maximum amount of time an established connection is allowed to live when it has no activity at all.",
				"def": "30s", "min": 0, "max": "1d" },

			{ "type": "monotonic", "name": "server_cnx_ttl_persist",
				"key": "server.cnx.timeout.persist",
				"descr": "In the current server, sets the maximum amount of time a connection is allowed to live, since its creation by the accept() call, whether it presents activity or not.",
				"def": "2h", "min": 0, "max": "1d" },

			{ "type": "monotonic", "name": "server_cnx_ttl_idle",
				"key": "server.cnx.timeout.idle",
				"descr": "In the current server, sets the maximum amount of time a connection may live without activity since the last activity (i.e. the last reply sent)",
				"def": "5m", "min": 0, "max": "1d" },

			{ "type": "monotonic", "name": "server_udp_queue_ttl",
				"key": "server.udp_queue.ttl",
				"descr": "In the current server, sets the maximum amount of time a queued UDP frame may remain in the queue. When unqueued, if the message was queued for too long, it will be dropped. The purpose of such a mechanism is to avoid clogging the queue and the whole election/cache mechanisms with old messages, those messages having already been resent.",
				"def": "2s", "min": "100ms", "max": "1d" },

			{ "type": "uint", "name": "server_udp_queue_maxlen",
				"key": "server.udp_queue.max",
				"descr": "In the current server, sets the maximum length of the queue for UDP messages. When that number has been reached and a new message arrives, the message will be dropped.",
				"def": 8192, "min": 0, "max": "1 << 32 - 1" },

			{ "type": "monotonic", "name": "server_queue_max_delay",
				"key": "server.queue.max_delay",
				"descr": "Anti-DDoS counter-mesure. In the current server, sets the maximum amount of time a queued TCP event may remain in the queue. If an event is polled and the thread sees the event stayed longer than that delay, the connection is immediately closed. Keep this value rather high because the connection closing doesn't involve a reply that will help the client to retry with an exponential back-off.",
				"def": "5s", "min": "10ms", "max": "1h" },

			{ "type": "monotonic", "name": "server_queue_warn_delay",
				"key": "server.queue.warn_delay",
				"descr": "In the current server, set the time threshold after which a warning is sent when a file descriptor stays longer than that in the queue of the Thread Pool.",
				"def": "100ms", "min": "1ms", "max": "1h" },

			{ "type": "monotonic", "name": "meta_queue_max_delay",
				"key": "meta.queue.max_delay",
				"descr": "Anti-DDoS counter-mesure. In the current server, sets the maximum amount of time a queued TCP event may remain in the queue. If an event is polled and the thread sees the event stayed longer than that delay, A '503 Unavailabe' error is replied.",
				"def": "2s", "min": "10ms", "max": "1h" },

			{ "type": "int32", "name": "oio_server_request_failure_threshold",
				"key": "enbug.server.request.failure.threshold",
				"descr": "In testing situations, sets the average ratio of requests failing for a fake reason (from the peer). This helps testing the retrial mechanisms.",
				"def": 30, "min": 0, "max": 100 },

			{ "type": "uint", "name": "malloc_trim_size_ondemand",
				"key": "server.malloc_trim_size.ondemand",
				"descr": "Sets how many bytes bytes are released when the LEAN request is received by the current 'meta' service.",
				"def": 0, "min": 0, "max": "1<<32 - 1" },

			{ "type": "uint", "name": "sqlx_periodic_malloctrim_period",
				"key": "server.task.malloc_trim.period",
				"descr": "In jiffies, how often the periodic task that calls malloc_trim() is fired.",
				"def": 3600, "min": 0, "max": "86400" },

			{ "type": "uint", "name": "sqlx_periodic_malloctrim_size",
				"key": "server.malloc_trim_size.periodic",
				"descr": "Sets how many bytes bytes are released when the LEAN request is received by the current 'meta' service.",
				"def": 0, "min": 0, "max": "1<<32 - 1" },

			{ "type": "uint", "name": "sqlx_periodic_decache_period",
				"key": "server.periodic_decache.period",
				"descr": "In ticks / jiffies, with approx. 1 tick per second. 0 means never",
				"def": 1, "min": 0, "max": "1Mi" },

			{ "type": "uint", "name": "sqlx_periodic_decache_max_bases",
				"key": "server.periodic_decache.max_bases",
				"descr": "How many bases may be decached each time the background task performs its Dance of Death",
				"def": 100, "min": 1, "max": "4Mi" },

			{ "type": "monotonic", "name": "sqlx_periodic_decache_max_delay",
				"key": "server.periodic_decache.max_delay",
				"descr": "How long may the decache routine take",
				"def": "500ms", "min": "1ms", "max": "1m" },

			{ "type": "monotonic", "name": "sqlx_request_max_delay_start",
				"key": "server.request.max_delay_start",
				"descr": "How long a request might take to start executing on the server side. This value is used to compute a deadline for several waitings (DB cache, manager of elections, etc). Common to all sqliterepo-based services, it might be overriden.",
				"def": "30s", "min": "1ms", "max": "1h" }
		]
	},
	"proxy": {
		"code": "proxy_variables.c",
		"header": "proxy_variables.h",
		"variables": [
			{ "type": "monotonic", "name": "proxy_request_max_delay",
				"key": "proxy.request.max_delay",
				"descr": "How long a request might take to execute, when no specific deadline has been received. Used to compute a deadline transmitted to backend services, when no timeout is present in the request.",
				"def": "1m", "min": "1ms", "max": "1h" },

			{ "type": "bool", "name": "oio_proxy_srv_shuffle",
				"key": "proxy.srv_shuffle",
				"descr": "Should the proxy shuffle the services addresses before the query, to do a better load-balancing of the requests.",
				"def": true },

			{ "type": "bool", "name": "oio_proxy_dir_shuffle",
				"key": "proxy.dir_shuffle",
				"descr": "Should the proxy shuffle the meta1 addresses before contacting them, thus trying to perform a better fanout of the requests.",
				"def": true },

			{ "type": "epoch", "name": "csurl_refresh_delay",
				"key": "proxy.period.refresh.csurl",
				"descr": "In the proxy, tells the period between the reloadings of the conscience URL, known from the local configuration",
				"def": "30s", "min": 0, "max": "1d" },

			{ "type": "epoch", "name": "srvtypes_refresh_delay",
				"key": "proxy.period.refresh.srvtypes",
				"descr": "In the proxy, tells the period between two refreshes of the known service types, from the conscience",
				"def": "30s", "min": "1s", "max": "1d" },

			{ "type": "epoch", "name": "nsinfo_refresh_delay",
				"key": "proxy.period.reload.nsinfo",
				"descr": "In the proxy, tells the period between two refreshes of the namespace configuration, from the conscience",
				"def": "30s", "min": "1s", "max": "1h" },

			{ "type": "monotonic", "name": "ttl_expire_local_services",
				"key": "proxy.ttl.services.local",
				"descr": "In the proxy cache, sets the TTL of a local service",
				"def": "30s", "min": 0, "max": "1d" },

			{ "type": "monotonic", "name": "ttl_down_services",
				"key": "proxy.ttl.services.down",
				"descr": "In the proxy cache, sets the TTL of a service known to be down",
				"def": "5s", "min": 0, "max": "1d" },

			{ "type": "monotonic", "name": "ttl_known_services",
				"key": "proxy.ttl.services.known",
				"descr": "In a proxy, sets the TTL of each service already encountered",
				"def": "5d", "min": 0, "max": "7d" },

			{ "type": "monotonic", "name": "ttl_expire_master_services",
				"key": "proxy.ttl.services.master",
				"descr": "In a proxy, sets the TTL on each 'known master' entry. That cache is filled each time a redirection to a MASTER occurs, so that we can immediately direct write operation to the service that owns the MASTER copy.",
				"def": "5s", "min": 0, "max": "7d" },

			{ "type": "epoch", "name": "lb_downstream_delay",
				"key": "proxy.period.cs.downstream",
				"descr": "In a proxy, sets the period between the refreshes of the load-balancing state from the central conscience.",
				"def": "5s", "min": 0, "max": "1m" },

			{ "type": "epoch", "name": "lb_upstream_delay",
				"key": "proxy.period.cs.upstream",
				"descr": "In a proxy, sets the period between two sendings of services states to the conscience.",
				"def": "1s", "min": "1s", "max": "1m" },

			{ "type": "uint", "name": "proxy_bulk_max_create_many",
				"key": "proxy.bulk.max.create_many",
				"descr": "In a proxy, sets how many containers can be created at once.",
				"def": "100", "min": 0, "max": "10k" },

			{ "type": "uint", "name": "proxy_bulk_max_delete_many",
				"key": "proxy.bulk.max.delete_many",
				"descr": "In a proxy, sets how many objects can be deleted at once.",
				"def": "100", "min": 0, "max": "10k" },

			{ "type": "bool", "name": "flag_cache_enabled",
				"key": "proxy.cache.enabled",
				"descr": "In a proxy, sets if any form of caching is allowed",
				"def": true,
				"aliases": ["Cache"]},

			{ "type": "bool", "name": "flag_local_scores",
				"key": "proxy.quirk.local_scores",
				"descr": "In a proxy, tells if the (ugly-as-hell) quirk that sets the score known from the conscience on the corresponding entries in the cache of services 'known to be local'",
				"def": false,
				"aliases": ["LocalScores"]},

			{ "type": "bool", "name": "flag_prefer_master_for_write",
				"key": "proxy.prefer.master_for_write",
				"descr": "In a proxy, upon a write request, should the proxy prefer services known to host the MASTER copy of the DB ",
				"def": true,
				"aliases": ["PreferMasterForWrites"]},

			{ "type": "bool", "name": "flag_prefer_master_for_read",
				"key": "proxy.prefer.master_for_read",
				"descr": "In a proxy, upon a read request, should the proxy prefer a service known to host a MASTER copy of the DB. Supersedes proxy.prefer.slave_for_read",
				"def": false,
				"aliases": ["PreferMaster"]},

			{ "type": "bool", "name": "flag_prefer_slave_for_read",
				"key": "proxy.prefer.slave_for_read",
				"descr": "In a proxy, upon a read request, should the proxy prefer a service known to host a SLAVE copy of the DB.",
				"def": false,
				"aliases": ["PreferSlave"]},

			{ "type": "bool", "name": "flag_force_master",
				"key": "proxy.force.master",
				"descr": "In a proxy, should the process ask the target service (with the help of an option in each RPC) to accept the RPC only if it is MASTER on that DB.",
				"def": false,
				"aliases": ["ForceMaster"]},

			{ "type": "uint", "name": "proxy_url_path_maxlen",
				"key": "proxy.url.path.maxlen",
				"descr": "In a proxy, sets the maximum length for the URL it receives. This options protects stack allocation for that URL.",
				"def": 2048, "min": 32, "max": 65536 },

			{ "type": "float", "name": "proxy_timeout_info",
				"key": "proxy.outgoing.timeout.info",
				"descr": "In a proxy, sets the global timeout for 'info' requests issued",
				"def": 5.0, "min": 0.01, "max": 60.0 },

			{ "type": "float", "name": "proxy_timeout_config",
				"key": "proxy.outgoing.timeout.config",
				"descr": "In a proxy, sets the global timeout for 'config' requests issued",
				"def": 5.0, "min": 0.01, "max": 60.0 },

			{ "type": "float", "name": "proxy_timeout_stat",
				"key": "proxy.outgoing.timeout.stat",
				"descr": "In a proxy, sets the global timeout for 'stat' requests issued (mostly forwarded for the event-agent)",
				"def": 5.0, "min": 0.01, "max": 60.0 },

			{ "type": "float", "name": "proxy_timeout_conscience",
				"key": "proxy.outgoing.timeout.conscience",
				"descr": "In a proxy, sets the global timeout for the RPC to the central conscience service.",
				"def": 2.0, "min": 0.01, "max": 60.0 },

			{ "type": "float", "name": "proxy_timeout_common",
				"key": "proxy.outgoing.timeout.common",
				"descr": "In a proxy, sets the global timeout for all the other RPC issued (not conscience, not stats-related)",
				"def": 30.0, "min": 0.01, "max": 60.0 }
		]
	},
	"client": {
		"license": "lgpl",
		"code": "client_variables.c",
		"header": "client_variables.h",
		"variables": [
			{ "type": "bool", "name": "oio_sds_default_autocreate",
				"key": "core.sds.autocreate",
				"descr": "In the current oio-sds client SDK, should the entities be autocreated while accessed for the first time. So, when pushing a content in a container, when this option is set to 'true', the USER and the CONTAINER will be created and configured to the namespace's defaults.",
				"def": false, "declare": false },

			{ "type": "bool", "name": "oio_sds_no_shuffle",
				"key": "core.sds.noshuffle",
				"descr": "In the current oio-sds client SDK, should the rawx services be shuffled before accessed. This helps ensuring a little load-balancing on the client side.",
				"def": false },

			{ "type": "monotonic", "name": "_refresh_major_minor",
				"key": "core.period.refresh.major_minor",
				"descr": "Sets the minimal amount of time between two refreshes of the list of the major/minor numbers of the known devices, currently mounted on the current host. If the set of mounted file systems doesn't change, keep this value high.",
				"def": "30s", "min": "100ms", "max": "1h" },

			{ "type": "monotonic", "name": "_refresh_io_idle",
				"key": "core.period.refresh.io_idle",
				"descr": "Sets the minimal amount of time between two refreshes of the known IO-idle counters for the current host. Keep this small.",
				"def": "1s", "min": "100ms", "max": "1h" },

			{ "type": "float", "name": "oio_sqlx_timeout_req",
				"key": "sqlx.outgoing.timeout.req",
				"descr": "Sets the timeout for the requests issued to the SQLX services.",
				"def": 30.0, "min": 0.01, "max": 60.0 },

			{ "type": "monotonic", "name": "_refresh_cpu_idle",
				"key": "core.period.refresh.cpu_idle",
				"descr": "Sets the minimal amount of time between two refreshes of the known CPU-idle counters for the current host. Keep this value small.",
				"def": "1s", "min": "100ms", "max": "1h" },

			{ "type": "string", "name": "oio_core_http_user_agent",
				"key": "core.http.user_agent",
				"limit": 64,
				"def": "",
				"descr": "HTTP User-Agent to be used between any C client and the proxy" },

			{ "type": "string", "name": "oio_sds_client_version",
				"key": "core.sds.version",
				"limit": 64,
				"def": "4.0",
				"descr": "The version of the sds. It's used to know the expected metadata of a chunk" }
		]
	}
}
