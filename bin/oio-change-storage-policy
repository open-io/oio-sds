#!/usr/bin/env python

# Copyright (C) 2025 OVH SAS
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


import argparse

from oio.api.object_storage import ObjectStorageApi
from oio.cli import get_logger_from_args, make_logger_args_parser
from oio.common.exceptions import NoSuchAccount, NoSuchContainer, NotFound, OioException
from oio.common.utils import depaginate, request_id

SEPARATOR = "/"


class OioChangeStoragePolicy:
    """
    Find all objects using the storage policy to change,
    then rewrite each object with the new storage policy.
    """

    def __init__(
        self,
        namespace,
        logger,
        storage_policy,
        new_storage_policy,
        ignore_pending_transition=False,
        accounts=None,
        containers=None,
        object_name=None,
        version=None,
        dry_run=False,
    ):
        self.api = ObjectStorageApi(namespace, logger=logger)
        self.logger = logger
        self.storage_policy = storage_policy
        self.new_storage_policy = new_storage_policy
        self.region = self.api.bucket.region.upper()
        self._account_marker = None
        self._container_marker = None
        self._main_request_id = self._request_id
        self._accounts = accounts
        self._containers = containers
        self._obj_name = object_name
        self._version = version
        self.dry_run = dry_run

    @property
    def _request_id(self):
        return request_id("oio-change-storage-policy-")

    @property
    def progress(self):
        """Format the current progression marker"""
        return f"{self._account_marker or ''}{SEPARATOR}{self._container_marker or ''}"

    def _custom_container_list(
        self,
        account,
        limit=None,
        marker=None,
        end_marker=None,
        prefix=None,
        region=None,
        **kwargs,
    ):
        res = self.api.account.container_list(
            account,
            limit=limit,
            marker=marker,
            end_marker=end_marker,
            prefix=prefix,
            region=region,
            **kwargs,
        )
        need_to_parse_container = False
        # Container list returns containers located
        # on local and other regions
        if self.region not in res["regions"]:
            self.logger.debug(
                f"Account={account} does not have containers "
                f"on the specified region={self.region}"
            )
        else:
            objects_count = res["regions"][self.region]["objects-details"].get(
                self.storage_policy
            )
            if objects_count is None:
                self.logger.debug(
                    f"The containers of account={account}, "
                    f"region={self.region} do not have objects with "
                    f"the specified storage policy: {self.storage_policy}"
                )
            elif objects_count <= 0:
                # Unless the account is refreshed, storage policies no longer used
                # in the account remain visible in the stats (with a counter at 0).
                # But since transitions immediately change the storage policy stats
                # before modifying the data, it is possible to have a transition
                # in progress (potentially blocked) while the counter indicates 0.
                # So also check the containers of the accounts with a counter of 0
                # to make sure that there are no more transitions in progress.
                if self._ignore_pending_transition:
                    self.logger.debug(
                        f"The containers of account={account}, "
                        f"region={self.region} no longer has objects with "
                        f"the specified storage policy: {self.storage_policy}"
                    )
                else:
                    need_to_parse_container = True
            else:  # objects_count > 0
                need_to_parse_container = True
        if not need_to_parse_container:
            return {"listing": [], "truncated": False}
        return res

    def _get_containers(self, marker=(None, None)):
        accounts = self._accounts
        account_marker = None
        container_marker = None
        if not accounts:
            account_marker, container_marker = marker
            accounts = depaginate(
                self.api.account.account_list,
                listing_key=lambda x: x["listing"],
                item_key=lambda x: x["id"],
                marker_key=lambda x: x["next_marker"],
                truncated_key=lambda x: x["truncated"],
                marker=account_marker,
                reqid=self._main_request_id,
            )
        for account in accounts:
            containers = self._containers
            if not containers:
                self.logger.info(
                    "Listing containers for account %s",
                    account,
                )
                containers = depaginate(
                    self._custom_container_list,
                    listing_key=lambda x: x["listing"],
                    marker_key=lambda x: x["next_marker"],
                    truncated_key=lambda x: x["truncated"],
                    account=account,
                    marker=container_marker,
                    reqid=self._main_request_id,
                    region=self.region,
                )
                container_marker = None

            for container in containers:
                yield account, container[0]

    def _change_storage_policy(self, account, container, obj_name, obj_version):
        """Change the policy of the specified object

        :param account: account name
        :type account: str
        :param container: container name
        :type container: str
        :param obj_name: object name
        :type obj_name: str
        :param obj_version: object version
        :type obj_version: str
        """
        if self.dry_run:
            return
        try:
            # Initiate policy transition to prepare for
            # the effective policy change by transition event agent
            self.api.object_request_transition(
                account=account,
                container=container,
                obj=obj_name,
                policy=self.new_storage_policy,
                version=obj_version,
                reqid=self._main_request_id,
                force_event_emit=True,
            )
        except OioException as exc:
            self.logger.error(
                "Unable to change policy for object: %s, in "
                "container=%s, account=%s, reason: %s",
                obj_name,
                container,
                account,
                exc,
            )

    def process(self, marker=(None, None)):
        """Change object policy if needed"""
        for account, container in self._get_containers(marker=marker):
            obj_per_container = 0
            self.logger.debug(
                "Fetching container info for account=%s container=%s",
                account,
                container,
            )
            reqid = self._main_request_id
            try:
                if self._obj_name:
                    obj_list = [
                        {
                            "name": self._obj_name,
                            "version": self._version,
                            "policy": self.storage_policy,
                        }
                    ]
                else:
                    self.logger.info(
                        "Listing objects in container %s, account %s",
                        container,
                        account,
                    )
                    obj_list = depaginate(
                        self.api.object_list,
                        listing_key=lambda x: x["objects"],
                        marker_key=lambda x: x.get("next_marker"),
                        version_marker_key=lambda x: x.get("next_version_marker"),
                        truncated_key=lambda x: x["truncated"],
                        account=account,
                        container=container,
                        properties=False,
                        versions=True,
                        reqid=reqid,
                    )
                try:
                    for obj in obj_list:
                        if obj["deleted"]:
                            # Delete marker does not have storage policy
                            continue
                        if obj["policy"] != self.storage_policy:
                            # Object does not have the specified storage policy
                            continue
                        if (
                            self._ignore_pending_transition
                            and obj.get("target_policy") is not None
                        ):
                            # A transition has already been requested on the object
                            continue
                        obj_name = obj["name"]
                        obj_version = obj["version"]
                        obj_per_container += 1
                        self._change_storage_policy(
                            account, container, obj_name, obj_version
                        )
                finally:
                    self.logger.info(
                        "%d objects transitioned for container %s, account %s",
                        obj_per_container,
                        container,
                        account,
                    )

            except (NoSuchAccount, NoSuchContainer, NotFound) as exc:
                self.logger.error(
                    "Unable to process container account=%s, container=%s, reason: %s",
                    account,
                    container,
                    exc,
                )
                continue
            finally:
                self._container_marker = container
                self._account_marker = account


def make_arg_parser():
    log_parser = make_logger_args_parser()
    descr = OioChangeStoragePolicy.__doc__

    parser = argparse.ArgumentParser(description=descr, parents=[log_parser])
    parser.add_argument("namespace", help="Namespace")
    parser.add_argument(
        "--storage-policy",
        required=True,
        help=(
            "Only objects with specified storage policy will be selected "
            '(e.g: "STD-E93")'
        ),
    )
    parser.add_argument(
        "--new-storage-policy",
        required=True,
        help='Storage policy to use when rewriting objects (e.g: "STD-R3")',
    )
    parser.add_argument(
        "--ignore-pending-transition",
        action="store_true",
        help="Ignore pending transitions because a previous request has been made",
    )
    parser.add_argument("--marker", help="Marker", default="")
    parser.add_argument(
        "--accounts",
        nargs="+",
        metavar="<account_name>",
        help="Account(s) name",
    )
    parser.add_argument(
        "--containers",
        nargs="+",
        metavar="<container_name>",
        help="Container name(s)",
    )
    parser.add_argument("--key", help="Object name", default=None)
    parser.add_argument("--version", help="Object version", default=None)

    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Display the number of objects per container that would change "
        "storage policy but do nothing (default=False)",
    )

    return parser


def main():
    args = make_arg_parser().parse_args()
    logger = get_logger_from_args(args)

    marker = (None, None)
    if args.marker:
        parts = args.marker.split(SEPARATOR, 1)
        if len(parts) != 2:
            logger.error(
                f"Marker wrong format, expected format: account{SEPARATOR}container"
            )
            return
        account_marker = parts[0] if parts[0] else None
        container_marker = parts[1] if parts[1] else None
        marker = (account_marker, container_marker)
    accounts = args.accounts
    containers = args.containers
    if containers:
        containers = [[container] for container in containers]
        if not accounts or (accounts and len(accounts) != 1):
            logger.error("Containers requires one account name.")
            return
    object_name = args.key
    if object_name:
        if not containers or (containers and len(containers) != 1):
            logger.error("Key requires one container name")
            return
    version = args.version
    if version:
        if not object_name:
            logger.error("Version requires key")
            return
        try:
            version = int(version)
        except Exception as exc:
            logger.error("Invalid version %s", exc)
            return

    change_storage_policy = OioChangeStoragePolicy(
        args.namespace,
        logger,
        args.storage_policy,
        args.new_storage_policy,
        ignore_pending_transition=args.ignore_pending_transition,
        accounts=accounts,
        containers=containers,
        object_name=object_name,
        version=version,
        dry_run=args.dry_run,
    )
    try:
        change_storage_policy.process(marker=marker)
    except KeyboardInterrupt:
        logger.info("Exiting...")
        print(f"Next marker: {change_storage_policy.progress}")
    except Exception as exc:
        logger.critical("Failure during process %s", exc)
        print(f"Next marker: {change_storage_policy.progress}")


if __name__ == "__main__":
    main()
