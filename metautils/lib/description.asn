AWL-MetaDirectory-Protocol DEFINITIONS AUTOMATIC TAGS ::=
BEGIN

	-- general purpose message structures

	ContentList ::= SEQUENCE OF PrintableString

	ArrayList ::= SEQUENCE OF OCTET STRING

	Parameter ::= SEQUENCE {
			name PrintableString,
			value OCTET STRING
	}

	ParameterSequence ::= SEQUENCE OF Parameter

	EventSequence ::= SEQUENCE OF ParameterSequence

	Message ::= SEQUENCE {
		id      [0] OCTET STRING OPTIONAL,
		name    [1] OCTET STRING OPTIONAL,
		version [2] OCTET STRING OPTIONAL,
		body    [3] OCTET STRING OPTIONAL,
		content [4] SET OF Parameter
	}

	-- General network address information

	AddrInfo ::= SEQUENCE {
		ip   [0] CHOICE {
			ipv4 [0] OCTET STRING(SIZE(4)),
			ipv6 [1] OCTET STRING(SIZE(16))
		},
		port [1] INTEGER
	}

	AddrInfoSequence ::= SEQUENCE OF AddrInfo


	-- Content information

	ChunkId ::= SEQUENCE {
		id   [0] OCTET STRING(SIZE(16)),
		addr [1] AddrInfo,
		vol  [2] PrintableString
	}

	ChunkIdSequence ::= SET OF ChunkId

	ChunkInfo ::= SEQUENCE {
		id       [0] ChunkId,
		size     [1] INTEGER,
		position [2] INTEGER,
		nb       [3] INTEGER,
		md5      [4] OCTET STRING(SIZE(16))
	}

	ChunkInfoSequence ::= SET OF ChunkInfo


	-- Container content list information

	PathInfo ::= SEQUENCE {
		path           [0] PrintableString,
		size           [1] INTEGER OPTIONAL,
		userMetadata   [2] OCTET STRING OPTIONAL,
		systemMetadata [3] OCTET STRING OPTIONAL
	}

	PathInfoSequence ::= SET OF PathInfo

	-- Digested information spread by the cluster conscience

	-- Namespace information

	NamespaceInfoValueList ::= SET OF Parameter

	NamespaceInfo ::= SEQUENCE {
		name           [0] PrintableString,
		addr           [1] AddrInfo,
		chunkSize      [2] INTEGER,
		options        [3] NamespaceInfoValueList,
		storagePolicy  [4] NamespaceInfoValueList,
		dataSecurity   [5] NamespaceInfoValueList,
		dataTreatments [6] NamespaceInfoValueList,
		storageClass   [7] NamespaceInfoValueList
	}

	NamespaceInfoSequence ::= SET OF NamespaceInfo

	-- meta0 mapping information

	Meta0Info ::= SEQUENCE {
		prefix [0] OCTET STRING,
		addr   [1] AddrInfo
	}

	Meta0InfoSequence ::= SET OF Meta0Info


	-- Meta1 raw management structures

	Meta1RawContainer ::= SEQUENCE {
		id    [0] OCTET STRING(SIZE(32)),
		name  [1] PrintableString,
		meta2 [2] SEQUENCE OF AddrInfo,
		flags [3] OCTET STRING(SIZE(4))
	}


	-- Meta2 raw management structures

	Meta2RawChunk ::= SEQUENCE {
		id       [0] ChunkId,
		hash     [1] OCTET STRING(SIZE(16)),
		flags    [2] OCTET STRING(SIZE(4)),
		size     [3] INTEGER,
		position [4] INTEGER,
		metadata [5] PrintableString OPTIONAL
	}
	Meta2RawChunkSequence ::= SEQUENCE OF Meta2RawChunk

	Meta2RawContentHeader ::= SEQUENCE {
		path           [0] PrintableString,
		nbChunks       [1] INTEGER,
		size           [2] INTEGER,
		flags          [3] OCTET STRING(SIZE(4)),
		cID            [4] OCTET STRING(SIZE(32)),
		metadata       [5] OCTET STRING OPTIONAL,
		systemMetadata [6] OCTET STRING OPTIONAL,
		version        [7] INTEGER OPTIONAL
	}
	Meta2RawContentHeaderSequence ::= SEQUENCE OF Meta2RawContentHeader

	Meta2RawContent ::= SEQUENCE {
		header [0] Meta2RawContentHeader,
		chunks [1] SEQUENCE OF Meta2RawChunk
	}
	Meta2RawContentSequence ::= SEQUENCE OF Meta2RawContent

	-- Meta2V2 beans

	M2V2Alias ::= SEQUENCE {
		name             [0] PrintableString,
		version          [1] INTEGER,
		containerVersion [2] INTEGER,
		contentId        [3] OCTET STRING,
		mdsys            [4] PrintableString,
		ctime            [5] INTEGER,
		deleted          [6] BOOLEAN
	}

	M2V2ContentHeader ::= SEQUENCE {
		id     [0] OCTET STRING, 
		hash   [1] OCTET STRING OPTIONAL,
		policy [2] PrintableString OPTIONAL,
		size   [3] INTEGER
	}

	M2V2Chunk ::= SEQUENCE {
		hash  [0] OCTET STRING,
		id    [1] PrintableString,
		size  [2] INTEGER,
		ctime [3] INTEGER
	}

	M2V2Content ::= SEQUENCE {
		contentId   [0] OCTET STRING,
		chunkId     [1] PrintableString,
		position    [2] PrintableString
	}

	M2V2Property ::= SEQUENCE {
		aliasName    [0] PrintableString,
		aliasVersion [1] INTEGER,
		key          [2] PrintableString,
		value        [3] OCTET STRING
	}

	M2V2Bean ::= SEQUENCE {
		alias    [0] M2V2Alias OPTIONAL,
		header   [1] M2V2ContentHeader OPTIONAL,
		content  [2] M2V2Content OPTIONAL,
		chunk    [3] M2V2Chunk OPTIONAL,
		prop     [4] M2V2Property OPTIONAL
	}

	M2V2BeanSequence ::= SEQUENCE OF M2V2Bean

	-- Generic Service

	Score ::= SEQUENCE {
		value	  [0] INTEGER,
		timestamp [1] INTEGER
	}

	ServiceTag ::= SEQUENCE {
		name  [0] PrintableString,
		value [1] CHOICE {
			b     [0] BOOLEAN,
			i     [1] INTEGER,
			r     [2] REAL,
			s     [3] OCTET STRING,
			macro [4] SEQUENCE {
				type  [0] PrintableString,
				param [1] PrintableString
			}
		}
	}

	ServiceInfo ::= SEQUENCE {
		nsName [0] PrintableString,
		type   [1] PrintableString,
		addr   [2] AddrInfo,
		score  [3] Score,
		tags   [4] SEQUENCE OF ServiceTag OPTIONAL
	}

	ServiceInfoSequence ::= SEQUENCE OF ServiceInfo

	-- Extended version of the Meta2RawContent, suitable for v1.5+ META2
	-- contents representation.

	Meta2Property ::= SEQUENCE {
		name     [0] PrintableString,
		version  [1] INTEGER,
		value    [2] OCTET STRING
	}

	Meta2PropertySequence ::= SEQUENCE OF Meta2Property

	Meta2RawContentV2 ::= SEQUENCE {
		header      [0] Meta2RawContentHeader,
		chunks      [1] Meta2RawChunkSequence,
		services    [2] ServiceInfoSequence,
		properties  [3] Meta2PropertySequence
	}

	Meta2RawContentV2Sequence ::= SEQUENCE OF Meta2RawContentV2

	ContainerInfo ::= SEQUENCE {
		id    [0] OCTET STRING(SIZE(32)),
		size  [1] INTEGER
	}
	ContainerInfoSequence ::= SEQUENCE OF ContainerInfo

	-- SQLX related structures

	RowFieldValue ::= CHOICE {
		i [0] INTEGER,
		f [1] REAL,
		b [2] OCTET STRING,
		s [3] PrintableString,
		n [4] NULL
	}

	RowField ::= SEQUENCE {
		pos   [0] INTEGER,
		value [1] RowFieldValue
	}

	RowFieldSequence ::= SEQUENCE OF RowField

	Row ::= SEQUENCE {
		rowid  [0] INTEGER,
		fields [1] RowFieldSequence OPTIONAL
	}

	RowSet ::= SEQUENCE OF Row

	RowFieldType ::= ENUMERATED {
		typeInt   (0),
		typeBlob  (1),
		typeText  (2),
		typeFloat (3)
	}

	RowName ::= SEQUENCE {
		pos  [0] INTEGER,
		name [1] OCTET STRING,
		type [2] RowFieldType OPTIONAL
	}

	TableHeader ::= SEQUENCE OF RowName

	Table ::= SEQUENCE {
		name         [0] OCTET STRING,
		header       [1] TableHeader,
		rows         [2] RowSet,
		status       [3] INTEGER OPTIONAL,
		statusString [4] PrintableString OPTIONAL
	}

	TableSequence ::= SEQUENCE OF Table

	TableVersion ::= SEQUENCE {
		name    [0] PrintableString,
		version [1] INTEGER,
		when    [2] INTEGER
	}

	BaseVersion ::= SEQUENCE OF TableVersion

END
