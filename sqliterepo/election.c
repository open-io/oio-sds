/*
OpenIO SDS sqliterepo
Copyright (C) 2014 Worldine, original work as part of Redcurrant
Copyright (C) 2015 OpenIO, modified as part of OpenIO Software Defined Storage

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 3.0 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library.
*/

#include <stddef.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>

#include <metautils/lib/metautils.h>

#include "sqliterepo.h"
#include "hash.h"
#include "election.h"
#include "version.h"
#include "sqlx_remote.h"
#include "synchro.h"
#include "gridd_client_pool.h"
#include "internals.h"

#define EVENTLOG_SIZE 16
#define STATUS_FINAL(e) ((e) >= STEP_LOST)
#define OLDEST(now,delay) (now > delay ? now - delay : 0)
#define ON_ENUM(P,E) case P##E: return #E

typedef guint req_id_t;

enum sqlx_action_e
{
	ACTION_NONE,
	ACTION_PING,
	ACTION_FAIL,
	ACTION_RETRY, /* re-send getvers */
	ACTION_RESTART,
	ACTION_EXPIRE
};

enum election_step_e
{
	STEP_NONE,
	STEP_CANDREQ,
	STEP_CANDOK,
	STEP_LEAVING,
	STEP_PRELOST,
	STEP_PRELEAD,
	STEP_LOST,
	STEP_LEADER,
	STEP_FAILED,
};

enum event_type_e
{
	EVT_NONE = 0,
	EVT_DISCONNECTED,
	EVT_EXITING,

	EVT_GETVERS_OK,
	EVT_GETVERS_OUTDATED,
	EVT_GETVERS_CONCURRENT,
	EVT_GETVERS_ERROR,

	EVT_CREATE_OK,
	EVT_CREATE_KO,

	EVT_NODE_LEFT,

	EVT_MASTER_KO,
	EVT_MASTER_EMPTY,
	EVT_MASTER_OK,
	EVT_MASTER_CHANGE,

	EVT_RESYNC_REQ,
	EVT_RESYNC_DONE,

	EVT_LIST_OK,
	EVT_LIST_KO,

	EVT_LEAVE_OK,
	EVT_LEAVE_KO,
};

struct logged_event_s
{
	enum event_type_e event   :8;
	enum election_step_e pre  :8;
	enum election_step_e post :8;
};

struct election_manager_s
{
	struct election_manager_vtable_s *vtable;

	struct sqlx_peering_s *peering;
	struct sqlx_sync_s *sync;

	/* XXX(jfs): used to generate <uid> of election members */
	volatile guint32 next_uid;

	/* do not free or change the fields below */
	const struct replication_config_s *config;

	struct lru_tree_s *lrutree_members; /* all the elections */
	GPtrArray *garbage_member_keys;
	GMutex lock;

	/* how long we accept to wait for a status. */
	gint64 delay_wait;

	/* how long we wait before expiring a base */
	gint64 delay_expire_none;
	gint64 delay_expire_pending;
	gint64 delay_expire_final;

	/* how long we wait before failing a stalled election */
	gint64 delay_fail_idle;

	/* how long we wait before restarting a failed election. */
	gint64 delay_retry_pending;
	gint64 delay_retry_failed;

	/* how long we wait after the last USE sent to send a new */
	gint64 delay_ping_pending;
	gint64 delay_ping_final;
	gint64 delay_ping_failed;

	gboolean exiting;

	req_id_t next_id;

	GCond conds[SQLX_MAX_COND];
};

struct election_member_s
{
	struct election_manager_s *manager;
	struct sqlx_name_mutable_s name;
	hashstr_t *key;

	/* XXX(jfs): only used cast to a (void*), as context for watcher callbacks.
	   Without such a quirk, the watchers could cause a memory leak due to
	   Zookeeper's implementation */
	guint32 uid;

	gint64 last_status; /* last time the status was changed */
	gint64 last_USE; /* last time a USE request has been sent */
	gint64 last_atime; /* last time the app wanted to a status */

	gint64 myid; /* ID generated by zookeeper */
	gint64 master_id; /* ID of the master */
	gchar *master_url; /* First node of the children sequence (sorted by ID) */

	guint refcount;

	req_id_t reqid_PIPEFROM;
	req_id_t reqid_GETVERS;

	guint16 concurrent_GETVERS;
	guint16 errors_GETVERS;
	guint16 pending_GETVERS;
	guint16 sent_GETVERS;

	guint log_index : 8;
	enum election_step_e step : 8;

	char requested_USE : 1;
	char requested_PIPEFROM : 1;
	char requested_EXIT : 1;
	char pending_PIPEFROM : 1;
	char pending_watch : 1;

	struct logged_event_s log[EVENTLOG_SIZE];
};

gint64 oio_election_period_cond_wait = G_TIME_SPAN_SECOND;

static void _noop (gpointer p) { (void)p; }

static GPrivate th_local_key_manager = G_PRIVATE_INIT(_noop);

/* ------------------------------------------------------------------------- */

static void member_destroy(struct election_member_s *member);

static void _manager_clean(struct election_manager_s *manager);

enum election_mode_e _manager_get_mode (const struct election_manager_s *manager);

const char * _manager_get_local (const struct election_manager_s *manager);

static GError * _election_get_peers(struct election_manager_s *manager,
		const struct sqlx_name_s *n, gboolean nocache, gchar ***peers);


static GError * _election_trigger_RESYNC(struct election_manager_s *manager,
		const struct sqlx_name_s *n);

static GError * _election_init(struct election_manager_s *manager,
		const struct sqlx_name_s *n);

static GError * _election_start(struct election_manager_s *manager,
		const struct sqlx_name_s *n);

static GError * _election_exit(struct election_manager_s *manager,
		const struct sqlx_name_s *n);

static enum election_status_e _election_get_status(struct election_manager_s *m,
		const struct sqlx_name_s *n, gchar **master_url);

static struct election_manager_vtable_s VTABLE =
{
	_manager_clean,
	_manager_get_mode,
	_manager_get_local,
	_election_get_peers,
	_election_init,
	_election_start,
	_election_exit,
	_election_get_status,
	_election_trigger_RESYNC,
};

static void transition_error(struct election_member_s *member,
		enum event_type_e evt, enum ZOO_ERRORS zrc);

static void transition(struct election_member_s *member,
		enum event_type_e evt_type, void *evt_arg);

static void defer_PIPEFROM(struct election_member_s *member);

static gboolean defer_USE(struct election_member_s *member);

static void defer_GETVERS(struct election_member_s *member);

static void member_debug(const char *func, const char *tag,
		const struct election_member_s *m);

static enum sqlx_action_e _member_get_next_action (
		const struct election_member_s *m);

static gboolean wait_for_final_status(struct election_member_s *m,
		gint64 deadline);

static int gint64_cmp(register gint64 i1, register gint64 i2) { return CMP(i1,i2); }

static int
gint64_sort(gconstpointer p1, gconstpointer p2)
{
	return gint64_cmp(*(gint64*)p1, *(gint64*)p2);
}

static void
_thlocal_set_manager (struct election_manager_s *manager)
{
	g_private_replace (&th_local_key_manager, manager);
}

static struct election_manager_s *
_thlocal_get_manager (void)
{
	return g_private_get (&th_local_key_manager);
}

/* XXX Misc helpers -------------------------------------------------------- */

static gboolean
_is_over (const gint64 last, const gint64 delay)
{
	const gint64 now = oio_ext_monotonic_time ();
	return (0 != last && last < OLDEST(now,delay));
}

static GArray *
nodev_to_int64v(const struct String_vector *sv, const char *prefix)
{
	GArray *array = g_array_new(0, 0, sizeof(gint64));

	for (int32_t i=0; i<sv->count ;i++) {
		const char *s = sv->data[i];
		if (g_str_has_prefix(s, prefix)) {
			const char *stripe = strrchr(s,'-');
			if (NULL != stripe) {
				gint64 i64 = g_ascii_strtoll(stripe+1, NULL, 10);
				g_array_append_vals(array, &i64, 1);
			}
		}
	}

	if (array->len > 1)
		g_array_sort(array, gint64_sort);

	return array;
}

static const char *
_action2str(enum sqlx_action_e action)
{
	switch (action) {
		ON_ENUM(ACTION_,NONE);
		ON_ENUM(ACTION_,PING);
		ON_ENUM(ACTION_,FAIL);
		ON_ENUM(ACTION_,RETRY);
		ON_ENUM(ACTION_,RESTART);
		ON_ENUM(ACTION_,EXPIRE);
	}

	g_assert_not_reached ();
	return "!INVALID!";
}

static const char *
_step2str(enum election_step_e step)
{
	switch (step) {
		ON_ENUM(STEP_,NONE);
		ON_ENUM(STEP_,CANDREQ);
		ON_ENUM(STEP_,CANDOK);
		ON_ENUM(STEP_,LEAVING);
		ON_ENUM(STEP_,PRELOST);
		ON_ENUM(STEP_,PRELEAD);
		ON_ENUM(STEP_,LOST);
		ON_ENUM(STEP_,LEADER);
		ON_ENUM(STEP_,FAILED);
	}

	g_assert_not_reached ();
	return "!INVALID!";
}

static const char *
_evt2str(enum event_type_e evt)
{
	switch (evt) {
		ON_ENUM(EVT_,NONE);
		ON_ENUM(EVT_,DISCONNECTED);
		ON_ENUM(EVT_,EXITING);
		ON_ENUM(EVT_,GETVERS_OK);
		ON_ENUM(EVT_,GETVERS_OUTDATED);
		ON_ENUM(EVT_,GETVERS_CONCURRENT);
		ON_ENUM(EVT_,GETVERS_ERROR);
		ON_ENUM(EVT_,CREATE_OK);
		ON_ENUM(EVT_,CREATE_KO);
		ON_ENUM(EVT_,NODE_LEFT);
		ON_ENUM(EVT_,MASTER_KO);
		ON_ENUM(EVT_,MASTER_EMPTY);
		ON_ENUM(EVT_,MASTER_OK);
		ON_ENUM(EVT_,MASTER_CHANGE);
		ON_ENUM(EVT_,RESYNC_REQ);
		ON_ENUM(EVT_,RESYNC_DONE);
		ON_ENUM(EVT_,LIST_OK);
		ON_ENUM(EVT_,LIST_KO);
		ON_ENUM(EVT_,LEAVE_OK);
		ON_ENUM(EVT_,LEAVE_KO);
	}

	g_assert_not_reached ();
	return "!INVALID!";
}

/* Public API --------------------------------------------------------------- */

GError *
election_manager_create(struct replication_config_s *config,
		struct election_manager_s **result)
{
	EXTRA_ASSERT(result != NULL);
	EXTRA_ASSERT(config != NULL);

	*result = NULL;
	if (NULL == config->get_local_url || NULL == config->get_peers
		|| NULL == config->get_version || ELECTION_MODE_GROUP < config->mode)
		return NEWERROR(ERRCODE_PARAM, "Invalid configuration");

	struct election_manager_s *manager = g_malloc0(sizeof(*manager));
	manager->vtable = &VTABLE;
	manager->delay_wait = SQLX_DELAY_MAXWAIT;
	manager->delay_expire_none = 5 * G_TIME_SPAN_MINUTE;
	manager->delay_expire_pending = 5 * G_TIME_SPAN_MINUTE;
	manager->delay_expire_final = 5 * G_TIME_SPAN_MINUTE;
	manager->delay_fail_idle = SQLX_DELAY_MAXIDLE;
	manager->delay_retry_failed = SQLX_DELAY_RESTART_FAILED;
	manager->delay_retry_pending = SQLX_DELAY_ELECTION_REPLAY;
	manager->delay_ping_pending = SQLX_DELAY_PING_PENDING;
	manager->delay_ping_final = SQLX_DELAY_PING_FINAL;
	manager->delay_ping_failed = SQLX_DELAY_PING_FAILED;
	manager->config = config;
	manager->lrutree_members = lru_tree_create(
			(GCompareFunc)hashstr_quick_cmp,
			g_free, NULL, 0);

	g_mutex_init(&manager->lock);
	for (guint i=0; i<SQLX_MAX_COND ;i++)
		g_cond_init(manager->conds + i);

	*result = manager;
	return NULL;
}

void
election_manager_set_sync (struct election_manager_s *manager,
		struct sqlx_sync_s *sync)
{
	EXTRA_ASSERT(manager != NULL);
	EXTRA_ASSERT(sync != NULL);
	EXTRA_ASSERT(manager->vtable == &VTABLE);
	manager->sync = sync;
}

void
election_manager_set_peering (struct election_manager_s *manager,
		struct sqlx_peering_s *peering)
{
	EXTRA_ASSERT(manager != NULL);
	EXTRA_ASSERT(peering != NULL);
	EXTRA_ASSERT(manager->vtable == &VTABLE);
	manager->peering = peering;
}

GError *
election_has_peers (struct election_manager_s *m, const struct sqlx_name_s *n,
		gboolean nocache, gboolean *result)
{
	gchar **peers = NULL;
	GError *err = election_get_peers (m, n, nocache, &peers);
	if (err != NULL) {
		*result = FALSE;
		return err;
	}
	*result = peers != NULL && peers[0] != NULL;
	if (peers)
		g_strfreev(peers);
	return NULL;
}

GError *
election_get_peers (struct election_manager_s *m, const struct sqlx_name_s *n,
		gboolean nocache, gchar ***peers)
{
	if (!m) {
		if (peers)
			*peers = g_malloc0(sizeof(void*));
		return NULL;
	}
	return ((struct abstract_election_manager_s*)m)->vtable->election_get_peers
		(m,n,nocache,peers);
}

const char *
election_manager_get_local (const struct election_manager_s *m)
{
	if (!m)
		return NULL;
	return ((struct abstract_election_manager_s*)m)->vtable->get_local(m);
}

enum election_mode_e
election_manager_get_mode (const struct election_manager_s *m)
{
	if (!m)
		return ELECTION_MODE_NONE;
	return ((struct abstract_election_manager_s*)m)->vtable->get_mode(m);
}

static gboolean
_count_runner(hashstr_t *k, struct election_member_s *member,
		struct election_counts_s *count)
{
	(void) k;
	++ count->total;
	switch (member->step) {
		case STEP_NONE:
			++ count->none;
			return FALSE;
		case STEP_CANDREQ:
		case STEP_CANDOK:
		case STEP_LEAVING:
		case STEP_PRELOST:
		case STEP_PRELEAD:
			++ count->pending;
			return FALSE;
		case STEP_LOST:
			++ count->slave;
			return FALSE;
		case STEP_LEADER:
			++ count->master;
			return FALSE;
		case STEP_FAILED:
			++ count->failed;
			return FALSE;
	}
	g_assert_not_reached ();
	return TRUE;
}

struct election_counts_s
election_manager_count(struct election_manager_s *manager)
{
	MANAGER_CHECK(manager);
	EXTRA_ASSERT (manager->vtable == &VTABLE);

	struct election_counts_s count = {0};

	g_mutex_lock(&manager->lock);
	lru_tree_foreach_DEQ(manager->lrutree_members,
			(GTraverseFunc) _count_runner, &count);
	g_mutex_unlock(&manager->lock);
	return count;
}

static GError *
_election_get_peers(struct election_manager_s *manager,
		const struct sqlx_name_s *n, gboolean nocache, gchar ***result)
{
	SQLXNAME_CHECK(n);

	if (!manager || !manager->config || !manager->config->get_peers) {
		if (result)
			*result = NULL;
		return NULL;
	}

	gchar **peers = NULL;
	GError *err = manager->config->get_peers(manager->config->ctx, n, nocache, &peers);
	if (!err) {
		if (result)
			*result = peers;
		else
			g_strfreev (peers);
		return NULL;
	}
	if (peers) {
		g_strfreev (peers);
		peers = NULL;
	}

	g_prefix_error(&err, "get_peers(%s,%s): ", n->base, n->type);
	return err;
}

static void
_manager_clean(struct election_manager_s *manager)
{
	if (!manager)
		return;
	if (manager->lrutree_members)
		lru_tree_destroy(manager->lrutree_members);
	g_mutex_clear(&manager->lock);
	for (guint i=0; i<SQLX_MAX_COND ;i++)
		g_cond_clear(manager->conds + i);
	g_free(manager);
}

const char *
_manager_get_local (const struct election_manager_s *manager)
{
	MANAGER_CHECK(manager);
	EXTRA_ASSERT (manager->vtable == &VTABLE);
	if (!manager->config || !manager->config->get_local_url)
		return NULL;
	return manager->config->get_local_url (manager->config->ctx);
}

enum election_mode_e
_manager_get_mode (const struct election_manager_s *manager)
{
	MANAGER_CHECK(manager);
	EXTRA_ASSERT (manager->vtable == &VTABLE);
	if (!manager->config || manager->config->mode <= ELECTION_MODE_NONE)
		return ELECTION_MODE_NONE;
	return manager->config->mode;
}

/* XXX Member handling ----------------------------------------------------- */

static req_id_t
manager_next_reqid(struct election_manager_s *m)
{
	return ++ m->next_id;
}

static gboolean
member_has_action(struct election_member_s *m)
{
	return m->pending_GETVERS || m->pending_PIPEFROM || m->requested_PIPEFROM;
}

static const char*
member_get_url(struct election_member_s *m)
{
	return election_manager_get_local(MMANAGER(m));
}

static GError *
member_get_peers(struct election_member_s *m, gboolean nocache, gchar ***peers)
{
	return election_get_peers(MMANAGER(m),
			sqlx_name_mutable_to_const(&m->name), nocache, peers);
}

static void
member_decache_peers(struct election_member_s *m)
{
	GError *err = member_get_peers(m, TRUE, NULL);
	if (err) g_clear_error(&err);
}

static void
member_kickoff(struct election_member_s *m)
{
	transition(m, EVT_NONE, NULL);
}

static void
member_ref(struct election_member_s *m)
{
	++ m->refcount;
}

static void
member_unref(struct election_member_s *m)
{
	EXTRA_ASSERT (m->refcount > 0);
	-- m->refcount;
}

static GCond*
member_get_cond(struct election_member_s *m)
{
	register guint h = hashstr_hash(m->key);
	return MMANAGER(m)->conds + (h % SQLX_MAX_COND);
}

static GMutex*
member_get_lock(struct election_member_s *m)
{
	return &(MMANAGER(m)->lock);
}

static void
member_lock(struct election_member_s *m)
{
	g_mutex_lock(member_get_lock(m));
}

static void
member_unlock(struct election_member_s *m)
{
	g_mutex_unlock(member_get_lock(m));
}

static void
member_signal(struct election_member_s *m)
{
	g_cond_signal(member_get_cond(m));
}

static void
member_set_master_url(struct election_member_s *m, const char *u)
{
	oio_str_replace(&(m->master_url), u);
	if (u)
		member_debug(__FUNCTION__, "MASTER_URL", m);
}

static void
member_reset_master(struct election_member_s *m)
{
	m->master_id = -1;
	member_set_master_url(m, NULL);
}

static void
member_reset_pending(struct election_member_s *m)
{
	m->sent_GETVERS = 0;
	m->concurrent_GETVERS = 0;
	m->errors_GETVERS = 0;
	m->reqid_GETVERS = 0;
	m->reqid_PIPEFROM = 0;
	m->pending_GETVERS = 0;
	m->pending_PIPEFROM = 0;
}

static void
member_reset(struct election_member_s *m)
{
	member_reset_master(m);
	member_reset_pending(m);
	m->myid = -1;
}

static void
member_set_id(struct election_member_s *m, gint64 id)
{
	EXTRA_ASSERT(id >= 0);
	EXTRA_ASSERT(m->myid <= 0);
	m->myid = id;
	member_debug(__FUNCTION__, "ID", m);
}

static void
member_set_status(struct election_member_s *m, enum election_step_e s)
{
	m->last_status = oio_ext_monotonic_time ();
	m->step = s;
	if (STATUS_FINAL(s)) {
		member_debug(__FUNCTION__, "FINAL", m);
		member_signal(m);
	} else if (s == STEP_NONE) {
		member_signal(m);
	} /* else ... no need to signal waiting threads unless a final status */
}

static void
member_set_master_id(struct election_member_s *m, gint64 i64)
{
	EXTRA_ASSERT(i64 >= 0);
	if (i64 != m->master_id)
		member_set_master_url(m, NULL);
	m->master_id = i64;
	member_debug(__FUNCTION__, "MASTER_ID", m);
}

static void
member_log_event(struct election_member_s *member, enum election_step_e pre,
		enum event_type_e evt)
{
	struct logged_event_s *plog;
	plog = member->log + ((member->log_index++) % EVENTLOG_SIZE);
	plog->event = evt;
	plog->pre = pre;
	plog->post = member->step;
}

static gchar*
member_dump_log(struct election_member_s *member)
{
	GString *out= g_string_new("\n\tP: ");

	/* local url */
	g_string_append(out, member_get_url(member));

	/* the peers */
	gchar **peers = NULL;
	GError *err = member_get_peers(member, FALSE, &peers);
	if (err != NULL) {
		g_string_append_printf(out, "NOT MANAGED (%d) %s",
				err->code, err->message);
		g_clear_error(&err);
	}
	else if (peers) {
		for (gchar **p = peers; *p ;p++) {
			g_string_append_c(out, '|');
			g_string_append(out, *p);
		}
		g_strfreev(peers);
	}

	/* then the livelog */
	guint idx = member->log_index - 1;
	for (guint i=0; i<EVENTLOG_SIZE ;i++,idx--) {
		struct logged_event_s *plog = member->log + (idx % EVENTLOG_SIZE);
		if (!plog->pre && !plog->post)
			break;
		g_string_append_printf(out, "\n\t%s:%s:%s",
				_step2str(plog->pre),
				_evt2str(plog->event),
				_step2str(plog->post));
	}

	return g_string_free(out, FALSE);
}

static void
member_descr(const struct election_member_s *m, gchar *d, gsize ds)
{
	g_snprintf(d, ds,
			"%s [%"G_GINT64_FORMAT"/%"G_GINT64_FORMAT"/%s] %u/%u/%u [%.*s] [%s.%s]",
			_step2str(m->step), m->myid, m->master_id, m->master_url,
			m->refcount, m->pending_GETVERS, m->pending_PIPEFROM,
			(guint) hashstr_len(m->key), hashstr_str(m->key),
			m->name.base, m->name.type);
}

static void
member_trace(const char *func, const char *tag,
		const struct election_member_s *m)
{
	(void) func, (void) tag, (void) m;
#ifdef HAVE_EXTRA_DEBUG
	gchar d[512];
	if (!GRID_TRACE2_ENABLED())
		return;
	member_descr(m, d, sizeof(d));
	GRID_TRACE2("%s %s %s", tag ? tag : "", d, func ? func : "");
#endif
}

static void
member_debug(const char *func, const char *tag,
		const struct election_member_s *m)
{
	gchar d[512];
	member_descr(m, d, sizeof(d));
	GRID_DEBUG("%s %s %s", tag ? tag : "", d, func ? func : "");
}

static void
member_warn(const char *tag, const struct election_member_s *m)
{
	gchar d[512];
	member_descr(m, d, sizeof(d));
	GRID_WARN("%s %s", tag ? tag : "", d);
}

static gchar *
member_fullpath(struct election_member_s *member)
{
	return (member->myid >= 0)
		? g_strdup_printf("%s-%010"G_GINT64_FORMAT,
				hashstr_str(member->key), member->myid)
		: g_strdup_printf("%s-",
				hashstr_str(member->key));
}

static gchar *
member_masterpath(struct election_member_s *member)
{
	return (member->master_id < 0) ? NULL
		: g_strdup_printf("%s-%010"G_GINT64_FORMAT,
				hashstr_str(member->key), member->master_id);
}

static void
member_destroy(struct election_member_s *member)
{
	if (!member)
		return;

	EXTRA_ASSERT (member->refcount == 0);

	oio_str_clean (&member->master_url);
	g_free0 (member->key);
	sqlx_name_clean (&member->name);

	memset(member, 0, sizeof(*member));
	member->myid = member->master_id = -1;
	g_free(member);
}

static gboolean
member_group_master(struct election_member_s *member, GArray *i64v)
{
	EXTRA_ASSERT(i64v != NULL);
	EXTRA_ASSERT(i64v->len > 0);
	if (member->myid < 0)
		return FALSE;
	return g_array_index(i64v, gint64, 0) == member->myid;
}

static gboolean
member_in_group(struct election_member_s *member, GArray *i64v)
{
	guint i;
	gint64 i64;

	EXTRA_ASSERT(i64v != NULL);
	if (member->myid < 0)
		return FALSE;
	for (i=0; i<i64v->len ;i++) {
		i64 = g_array_index(i64v, gint64, i);
		if (i64 == member->myid)
			return TRUE;
	}
	return FALSE;
}

static struct election_member_s *
_LOCKED_get_member (struct election_manager_s *ma, const hashstr_t *k)
{
	struct election_member_s *m = lru_tree_get (ma->lrutree_members, k);
	if (m) member_ref (m);
	return m;
}

static struct election_member_s *
_LOCKED_init_member(struct election_manager_s *manager,
		const struct sqlx_name_s *n, gboolean autocreate)
{
	MANAGER_CHECK(manager);
	NAME_CHECK(n);

	struct hashstr_s *key = sqliterepo_hash_name(n);
	struct election_member_s *member = _LOCKED_get_member (manager, key);
	if (!member && autocreate) {
		member = g_malloc0 (sizeof(*member));
		member->uid = manager->next_id ++;
		member->manager = manager;
		member->last_status = oio_ext_monotonic_time ();
		member->key = hashstr_dup(key);
		member->name.base = g_strdup(n->base);
		member->name.type = g_strdup(n->type);
		member->name.ns = g_strdup(n->ns);
		member->myid = member->master_id = -1;
		member->refcount = 2;

		lru_tree_insert(manager->lrutree_members, hashstr_dup(key), member);
	}
	g_free(key);
	return member;
}

static struct election_member_s *
manager_get_member (struct election_manager_s *m, const hashstr_t *k)
{
	g_mutex_lock (&m->lock);
	struct election_member_s *member = _LOCKED_get_member (m, k);
	g_mutex_unlock (&m->lock);
	return member;
}

static gboolean
_count(gpointer k, gpointer v, gpointer u)
{
	(void) k;
	MEMBER_CHECK(v);
	enum election_step_e step = MEMBER(v)->step;
	if (step != STEP_NONE && step != STEP_FAILED)
		++ *((guint*)u);
	return FALSE;
}

static guint
manager_count_active(struct election_manager_s *manager)
{
	guint count = 0;
	g_mutex_lock(&manager->lock);
	lru_tree_foreach_TREE(manager->lrutree_members, _count, &count);
	g_mutex_unlock(&manager->lock);
	return count;
}

static void
manager_send_EXITING(struct election_manager_s *manager)
{
	gboolean send_exit(gpointer k, gpointer v, gpointer u) {
		(void) k; (void) u;
		MEMBER_CHECK(v);
		if (MEMBER(v)->step != STEP_NONE)
			transition(v, EVT_EXITING, NULL);
		return FALSE;
	}

	lru_tree_foreach_TREE(manager->lrutree_members, send_exit, NULL);
	GRID_INFO("EXIT order sent");
}

void
election_manager_exit_all(struct election_manager_s *manager, gint64 duration,
		gboolean persist)
{
	GRID_INFO("Voluntarily exiting all the elections...");
	MANAGER_CHECK(manager);
	EXTRA_ASSERT (manager->vtable == &VTABLE);
	gint64 pivot = oio_ext_monotonic_time () + duration;

	/* Order the node to exit */
	g_mutex_lock(&manager->lock);
	manager->exiting = TRUE;
	manager_send_EXITING(manager);
	g_mutex_unlock(&manager->lock);

	for (guint count; 0 < (count = manager_count_active(manager)) ;) {
		GRID_INFO("Waiting for %u active elections", count);
		if (oio_ext_monotonic_time () > pivot) {
			GRID_WARN("TIMEOUT while waiting for active elections");
			return;
		}
		g_usleep(500 * G_TIME_SPAN_MILLISECOND);
	}
	if (!persist)
		manager->exiting = FALSE;

	GRID_INFO("No more active elections");
}

void
election_manager_whatabout (struct election_manager_s *m,
		const struct sqlx_name_s *n, gchar *d, gsize ds)
{
	NAME_CHECK(n);
	MANAGER_CHECK(m);
	EXTRA_ASSERT (m->vtable == &VTABLE);
	EXTRA_ASSERT(d != NULL);
	EXTRA_ASSERT(ds > 0);

	hashstr_t *key = sqliterepo_hash_name(n);
	g_mutex_lock(&m->lock);
	struct election_member_s *member = _LOCKED_get_member(m, key);
	if (member) {
		member_descr (member, d, ds);
		member_unref (member);
		gchar *log = member_dump_log(member);
		g_strlcat(d, log, ds);
		g_free(log);
	}
	else {
		if (election_manager_get_mode(m) == ELECTION_MODE_NONE)
			g_snprintf(d, ds, "Replication disabled by configuration");
		else
			g_snprintf(d, ds, "No election for [%s][%s] [%s]",
					n->base, n->type, hashstr_str(key));
	}
	g_mutex_unlock(&m->lock);

	g_free(key);
}

/* XXX Zookeeper callbacks ----------------------------------------------------
   All of them are called from the zookeeper's thread.
   We chose to set the election manager in a thread-local slot because ZK
   contexts for callbackks currently (3.4.6) require that no memory is
   allocated, especially because of a memory leak on discarded clone watchers.
   We are forced to pass an integer cast into pointer so that watchers can use
   them to recover the right election.
   -------------------------------------------------------------------------- */

static void
step_AskMaster_completion(int zrc, const char *v, int vlen,
		const struct Stat *s, const void *d)
{
	(void) s;
	struct election_member_s *member = (struct election_member_s *)d;
	MEMBER_CHECK(member);
	member_trace(__FUNCTION__, "DONE", member);

	gchar *master = (v && vlen && *v) ? g_strndup(v, vlen) : NULL;
	member_lock(member);

	if (zrc != ZOK)
		transition_error(member, EVT_MASTER_KO, zrc);
	else {
		if (!master)
			transition(member, EVT_MASTER_EMPTY, &zrc);
		else
			transition(member, EVT_MASTER_OK, master);
	}
	member_unref(member);
	member_unlock(member);
	g_free0 (master);
}

static void
step_ListGroup_completion(int zrc, const struct String_vector *sv,
		const void *data)
{
	struct election_member_s *member = (struct election_member_s *) data;
	MEMBER_CHECK(member);
	member_trace(__FUNCTION__, "DONE", member);

	member_lock(member);

	if (zrc != ZOK)
		transition_error(member, EVT_LIST_KO, zrc);
	else {
		GArray *i64v = nodev_to_int64v(sv, hashstr_str(member->key));
		transition(member, EVT_LIST_OK, i64v);
		g_array_free(i64v, TRUE);
	}

	member_unref(member);
	member_unlock(member);
}

static void
step_LeaveElection_completion(int zrc, const void *d)
{
	if (!grid_main_is_running()) {
		GRID_DEBUG("%s ignored while exiting", __FUNCTION__);
		return;
	}

	struct election_member_s *member = (struct election_member_s *) d;
	MEMBER_CHECK(member);
	member_trace(__FUNCTION__, "DONE", member);

	member_lock(member);
	if (zrc == ZNONODE)
		transition(member, EVT_LEAVE_OK, NULL);
	else if (zrc != ZOK)
		transition_error(member, EVT_LEAVE_KO, zrc);
	else
		transition(member, EVT_LEAVE_OK, NULL);
	member_unref(member);
	member_unlock(member);
}

static void
step_WatchNode_completion(int zrc, const struct Stat *s, const void *d)
{
	(void) s;
	struct election_member_s *member = (struct election_member_s *) d;
	MEMBER_CHECK(member);
	member_lock(member);
	member_trace(__FUNCTION__, "DONE", member);
	if (zrc == ZNONODE)
		transition(member, EVT_NODE_LEFT, &zrc);
	member_unref(member);
	member_unlock(member);
}

static void
step_StartElection_completion(int zrc, const char *path, const void *d)
{
	struct election_member_s *member = (struct election_member_s *) d;
	MEMBER_CHECK(member);
	member_lock(member);
	member_trace(__FUNCTION__, "DONE", member);
	_thlocal_set_manager (member->manager);

	if (zrc != ZOK)
		transition_error(member, EVT_CREATE_KO, zrc);
	else {
		if (!path)
			transition(member, EVT_CREATE_KO, &zrc);
		else {
			gint64 i64 = g_ascii_strtoll(strrchr(path, '-')+1, NULL, 10);
			transition(member, EVT_CREATE_OK, &i64);
		}
	}
	member_unref(member);
	member_unlock(member);
}

static struct election_member_s *
_find_member (void *d)
{
	struct election_manager_s *manager = _thlocal_get_manager ();
	if (!manager)
		return NULL;

	struct election_member_s *member = NULL;
	guint64 u64 = (guint64) d;
	guint32 uid = u64;

	g_mutex_lock (&manager->lock);
	gboolean _locate (gpointer k, gpointer v, gpointer u) {
		(void) k, (void) u;
		if (((struct election_member_s*)v)->uid == uid) {
			member = v;
			return TRUE;
		}
		return FALSE;
	}
	lru_tree_foreach_DEQ (manager->lrutree_members, _locate, NULL);
	if (member) {
		member_ref (member);
		return member;
	}
	g_mutex_unlock (&manager->lock);
	return NULL;
}

static void
step_WatchMaster_change(zhandle_t *handle, int type, int state,
			const char *path, void *d)
{
	if (!grid_main_is_running()) {
		GRID_DEBUG("%s ignored while exiting", __FUNCTION__);
		return;
	}
	(void) handle, (void) type, (void) state, (void) path;

	struct election_member_s *member = _find_member(d);
	if (NULL != member) {
		member_trace(__FUNCTION__, "CHANGE", member);
		MEMBER_CHECK(member);
		transition(member, EVT_MASTER_CHANGE, NULL);
		member_unref(member);
		member_unlock(member);
	}
}

static void
step_WatchNode_change(zhandle_t *handle, int type, int state,
		const char *path, void *d)
{
	if (!grid_main_is_running()) {
		GRID_DEBUG("%s ignored while exiting", __FUNCTION__);
		return;
	}
	(void) handle, (void) type, (void) state, (void) path;

	struct election_member_s *member = _find_member(d);
	if (NULL != member) {
		MEMBER_CHECK(member);
		member_trace(__FUNCTION__, "CHANGE", member);
		transition(member, EVT_NODE_LEFT, NULL);
		member_unref(member);
		member_unlock(member);
	}
}

/* ------------------------------------------------------------------------- */

static void
member_warn_failed_creation(struct election_member_s *member, int zrc)
{
	gchar *p = member_fullpath(member);
	GRID_WARN("CREATE failed [%s.%s] [%s] : (%d) %s",
			member->name.base, member->name.type, p, zrc, zerror(zrc));
	g_free(p);
}

static int
step_StartElection_start(struct election_member_s *member)
{
	member_trace(__FUNCTION__, "ACTION", member);

	const char *myurl = member_get_url(member);
	gchar *path = member_fullpath(member);
	int zrc = sqlx_sync_acreate(member->manager->sync,
			path, myurl, strlen(myurl), ZOO_EPHEMERAL|ZOO_SEQUENCE,
			step_StartElection_completion, member);
	g_free(path);

	if (zrc == ZOK)
		member_ref(member);
	return zrc;
}

static int
step_AskMaster_start(struct election_member_s *member)
{
	int zrc = ZNONODE;
	gchar *path = NULL;

	member_trace(__FUNCTION__, "ACTION", member);
	void *d = GUINT_TO_POINTER(member->uid);

	if (NULL != (path = member_masterpath(member))) {
		zrc = sqlx_sync_awget(member->manager->sync, path,
				step_WatchMaster_change, d,
				step_AskMaster_completion, member);
		g_free(path);
		if (zrc == ZOK)
			member_ref(member);
	}

	return zrc;
}

static int
step_WatchNode_start(struct election_member_s *member)
{
	member_trace(__FUNCTION__, "ACTION", member);
	void *d = GUINT_TO_POINTER(member->uid);

	gchar *path = member_fullpath(member);
	int zrc = sqlx_sync_awexists(member->manager->sync, path,
			step_WatchNode_change, d,
			step_WatchNode_completion, member);
	g_free(path);
	if (zrc == ZOK)
		member_ref(member);
	return zrc;
}

static int
step_ListGroup_start(struct election_member_s *member)
{
	member_trace(__FUNCTION__, "ACTION", member);

	gchar *path = member_fullpath(member);
	int zrc = sqlx_sync_awget_siblings(member->manager->sync, path,
			NULL, NULL,
			step_ListGroup_completion, member);
	g_free(path);
	if (zrc == ZOK)
		member_ref(member);
	return zrc;
}

static int
step_LeaveElection_start(struct election_member_s *member)
{
	member_trace(__FUNCTION__, "ACTION", member);

	gchar *path  = member_fullpath(member);
	int zrc = sqlx_sync_adelete(member->manager->sync, path, -1,
			step_LeaveElection_completion, member);
	g_free(path);
	if (zrc == ZOK)
		member_ref(member);
	return zrc;
}

/* ------------------------------------------------------------------------- */

enum election_op_e {
	ELOP_NONE, ELOP_START, ELOP_RESYNC, ELOP_EXIT
};

static GError *
_election_make(struct election_manager_s *m, const struct sqlx_name_s *n,
		enum election_op_e op)
{
	MANAGER_CHECK(m);
	SQLXNAME_CHECK(n);

	if (op != ELOP_EXIT) {
		gboolean peers_present = FALSE;
		GError *err = election_has_peers(m, n, FALSE, &peers_present);
		if (err != NULL) {
			g_prefix_error(&err, "Election error: ");
			return err;
		}
		if (!peers_present) {
			GRID_DEBUG("No peer for [%s][%s]", n->base, n->type);
			return NULL;
		}
	}

	g_mutex_lock(&m->lock);
	struct election_member_s *member = _LOCKED_init_member(m, n, op != ELOP_EXIT);
	switch (op) {
		case ELOP_NONE:
			member->last_atime = oio_ext_monotonic_time ();
			break;
		case ELOP_START:
			member->last_atime = oio_ext_monotonic_time ();
			transition(member, EVT_NONE, NULL);
			break;
		case ELOP_RESYNC:
			member->last_atime = oio_ext_monotonic_time ();
			transition(member, EVT_RESYNC_REQ, NULL);
			break;
		case ELOP_EXIT:
			if (member)
				transition(member, EVT_EXITING, NULL);
			break;
	}
	if (member)
		member_unref(member);
	g_mutex_unlock(&m->lock);

	return NULL;
}

static GError *
_election_trigger_RESYNC(struct election_manager_s *manager,
		const struct sqlx_name_s *n)
{
	return _election_make(manager, n, ELOP_RESYNC);
}

static GError *
_election_init(struct election_manager_s *manager, const struct sqlx_name_s *n)
{
	return _election_make(manager, n, ELOP_NONE);
}

static GError *
_election_start(struct election_manager_s *manager, const struct sqlx_name_s *n)
{
	return _election_make(manager, n, ELOP_START);
}

static GError *
_election_exit(struct election_manager_s *manager, const struct sqlx_name_s *n)
{
	return _election_make(manager, n, ELOP_EXIT);
}

static gboolean
wait_for_final_status(struct election_member_s *m, gint64 deadline)
{
	while (!STATUS_FINAL(m->step)) {

		member_kickoff(m);

		const gint64 now = oio_ext_monotonic_time();
		m->last_atime = now;

		/* compare internal timers to our fake'able clock */
		if (now > deadline) {
			GRID_WARN("TIMEOUT! (wait) [%s.%s]", m->name.base, m->name.type);
			return FALSE;
		}
		if (ACTION_FAIL == _member_get_next_action(m)) {
			GRID_WARN("TIMEOUT! (pending) [%s.%s]", m->name.base, m->name.type);
			return FALSE;
		}

		GRID_TRACE("Still waiting for a final status on [%s.%s]",
				m->name.base, m->name.type);

		/* perform the real WAIT on the real clock. */
		g_cond_wait_until(member_get_cond(m), member_get_lock(m),
				g_get_monotonic_time() + oio_election_period_cond_wait);
	}

	m->last_atime = oio_ext_monotonic_time ();
	return TRUE;
}

static enum election_status_e
_election_get_status(struct election_manager_s *mgr,
		const struct sqlx_name_s *n, gchar **master_url)
{
	int rc;
	gchar *url = NULL;

	MANAGER_CHECK(mgr);
	EXTRA_ASSERT(n != NULL);

	gint64 deadline = oio_ext_monotonic_time () + mgr->delay_wait;

	g_mutex_lock(&mgr->lock);
	struct election_member_s *m = _LOCKED_init_member(mgr, n, TRUE);
	member_kickoff(m);

	if (!wait_for_final_status(m, deadline)) // TIMEOUT!
		rc = STEP_FAILED;
	else {
		rc = m->step;
		if (rc == STEP_LOST) {
			if (m->master_url)
				url = g_strdup(m->master_url);
		}
	}

	member_unref(m);
	if (rc == STEP_NONE || STATUS_FINAL(rc))
		member_signal(m);
	member_unlock(m);

	GRID_TRACE("STEP=%s/%d master=%s", _step2str(rc), rc, url);
	switch (rc) {
		case STEP_LEADER:
			return ELECTION_LEADER;
		case STEP_LOST:
			if (master_url)
				*master_url = url;
			else
				g_free(url);
			url = NULL;
			return ELECTION_LOST;
		default:
			return ELECTION_FAILED;
	}
}

/* ------------------------------------------------------------------------- */

static gboolean
defer_USE(struct election_member_s *member)
{
	gchar **peers = NULL;
	GError *err = member_get_peers(member, FALSE, &peers);
	if (err != NULL) {
		GRID_WARN("[%s] Election initiated (%s) but get_peers error: (%d) %s",
				__FUNCTION__, _step2str(member->step), err->code, err->message);
		g_clear_error(&err);
		return FALSE;
	}

	if (!peers || !*peers) {
		member_trace(__FUNCTION__, "USE avoided", member);
	} else {
		member->last_USE = oio_ext_monotonic_time();
		for (gchar **p=peers; p && *p ;p++)
			sqlx_peering__use (member->manager->peering, *p,
					sqlx_name_mutable_to_const(&member->name));
		member_trace(__FUNCTION__, "USE scheduled", member);
	}

	if (peers) g_strfreev(peers);
	return TRUE;
}

static void
_result_PIPEFROM (GError *e, struct election_manager_s *manager,
		const struct sqlx_name_s *n, guint reqid)
{
	hashstr_t *key = sqliterepo_hash_name (n);

	GRID_DEBUG("PIPEFROM result [%s.%s] [%s]: (%d) %s",
			n->base, n->type, hashstr_str(key),
			e?e->code:0, e?e->message:"OK");

	struct election_member_s *member = manager_get_member (manager, key);
	g_free (key);

	if (member) {
		member_lock(member);
		transition(member, EVT_RESYNC_DONE, &reqid);
		member_unref(member);
		member_unlock(member);
	}
}

static void
defer_PIPEFROM(struct election_member_s *member)
{
	MEMBER_CHECK(member);

	const char *source = member->master_url;
	const char *target = member_get_url(member);

	EXTRA_ASSERT(target != NULL);
	EXTRA_ASSERT(source != NULL);

	if (member->pending_PIPEFROM)
		member_debug(__FUNCTION__, "PIPEFROM avoided", member);
	else {
		member->reqid_PIPEFROM = manager_next_reqid(member->manager);
		member->requested_PIPEFROM = 0;
		member->pending_PIPEFROM = 1;

		sqlx_peering__pipefrom (member->manager->peering, target,
				sqlx_name_mutable_to_const(&member->name), source,
				member->manager, member->pending_PIPEFROM, _result_PIPEFROM);

		member_debug(__FUNCTION__, "PIPEFROM scheduled", member);
	}
}

static void
_result_GETVERS (GError *enet,
		struct election_manager_s *manager, const struct sqlx_name_s *name,
		guint reqid, GTree *vremote)
{
	GError *err = NULL;
	GTree *vlocal = NULL;

	EXTRA_ASSERT(manager != NULL);
	EXTRA_ASSERT(name != NULL);
	EXTRA_ASSERT((enet != NULL) ^ (vremote != NULL));

	if (!enet) {
		err = manager->config->get_version (manager->config->ctx, name, &vlocal);
		EXTRA_ASSERT ((err != NULL) ^ (vlocal != NULL));
	}
	if (!err && !enet) {
		gint64 worst = 0;
		err = version_validate_diff(vlocal, vremote, &worst);
		if (NULL != err) {
			if (err->code == CODE_PIPETO) {
				GRID_DEBUG("Remote outdated : (%d) %s",
						err->code, err->message);
				g_clear_error(&err);
			}
		} else {
			if (worst < 0)
				err = NEWERROR(CODE_PIPEFROM, "One diff missed");
		}
	}

	hashstr_t *key = sqliterepo_hash_name (name);
	struct election_member_s *member = manager_get_member(manager, key);
	if (!member) {
		GRID_WARN("GETVERS Election disappeared [%s]", hashstr_str(key));
	} else {

		MEMBER_CHECK(member);

		member_lock(member);
		if (!err)
			transition(member, EVT_GETVERS_OK, &reqid);
		else if (err->code == CODE_PIPEFROM)
			transition(member, EVT_GETVERS_OUTDATED, &reqid);
		else if (err->code == CODE_CONCURRENT)
			transition(member, EVT_GETVERS_CONCURRENT, &reqid);
		else {
			GRID_DEBUG("GETVERS error : (%d) %s", err->code, err->message);
			if (err->code == CODE_CONTAINER_NOTFOUND) {
				// We may have asked the wrong peer
				member_decache_peers(member);
			}
			transition(member, EVT_GETVERS_ERROR, &reqid);
		}
		member_unlock(member);
	}

	if (err) g_clear_error(&err);
	if (vlocal) g_tree_destroy(vlocal);
	g_free (key);
}

static void
defer_GETVERS(struct election_member_s *member)
{
	guint pending = 0;

	MEMBER_CHECK(member);
	GRID_TRACE2("%s(%p)", __FUNCTION__, member);

	gchar **peers = NULL;
	GError *err = member_get_peers(member, FALSE, &peers);
	if (err != NULL) {
		GRID_WARN("[%s] Election initiated (%s) but get_peers error: (%d) %s",
				__FUNCTION__, _step2str(member->step), err->code, err->message);
		g_clear_error(&err);
		return;
	}

	pending = g_strv_length(peers);

	if (member->sent_GETVERS > 0)
		member_debug(__FUNCTION__ , "GETVERS req lost", member);

	member->sent_GETVERS = pending;
	member->pending_GETVERS = pending;
	member->reqid_GETVERS = manager_next_reqid(member->manager);

	for (gchar **p=peers; p && *p; p++)
		sqlx_peering__getvers (member->manager->peering, *p,
				sqlx_name_mutable_to_const(&member->name), member->manager,
				member->reqid_GETVERS, _result_GETVERS);

	member_trace(__FUNCTION__ , "GETVERS scheduled", member);
	g_strfreev(peers);
}

/* -------------------------------------------------------------------------- */

static void
member_ask_RESYNC_if_not_pending(struct election_member_s *member)
{
	if (!member->pending_PIPEFROM)
		member->requested_PIPEFROM = 1;
}

static void
become_failed (struct election_member_s *member)
{
	member_set_status(member, STEP_FAILED);
}

static void
become_leaver(struct election_member_s *member)
{
	member_reset_master(member);
	member_reset_pending(member);
	member_set_status(member, STEP_LEAVING);
	int zrc = step_LeaveElection_start(member);
	if (zrc != ZOK)
		member_set_status(member, STEP_FAILED);
}

static void
become_candidate(struct election_member_s *member)
{
	member_reset_master(member);
	member_set_status(member, STEP_CANDOK);
	if (ZOK != step_ListGroup_start(member))
		member_set_status(member, STEP_FAILED);
}

static void
restart_election(struct election_member_s *member)
{
	if (member->myid > 0)
		return become_leaver(member);

	member_reset(member);
	if (member->manager->exiting) {
		member_set_status(member, STEP_NONE);
		return;
	}

	member->requested_USE = 0;

	member_set_status(member, STEP_CANDREQ);
	if (!defer_USE(member)) {
		member_set_status(member, STEP_FAILED);
		return;
	}
	int zrc = step_StartElection_start(member);
	if (ZOK != zrc) {
		member_warn_failed_creation(member, zrc);
		member_set_status(member, STEP_FAILED);
	}
}

static gboolean
member_concerned_by_GETVERS(struct election_member_s *member, guint *reqid)
{
	if (*reqid != member->reqid_GETVERS)
		return FALSE;
	if (member->pending_GETVERS > 0) {
		if (! -- member->pending_GETVERS)
			member->reqid_GETVERS = 0;
	}
	return TRUE;
}

static void
member_finish_PRELOST(struct election_member_s *member)
{
	if (member_has_action(member))
		return;

	int errors = member->errors_GETVERS;
	member->errors_GETVERS = 0;
	int concurrent = member->concurrent_GETVERS;
	member->concurrent_GETVERS = 0;

	// FIXME compare to the sizeof of the quorum
	if (errors > 1) {
		become_leaver(member);
	} else if (concurrent > 1) {
		member_ask_RESYNC_if_not_pending(member);
	} else {
		if (member->master_url)
			member_set_status(member, STEP_LOST);
	}
}

static void
member_finish_PRELEAD(struct election_member_s *member)
{
	if (member_has_action(member))
		return;

	int errors = member->errors_GETVERS;
	member->errors_GETVERS = 0;
	int concurrent = member->concurrent_GETVERS;
	member->concurrent_GETVERS = 0;

	// FIXME compare to the sizeof of the quorum
	if (errors > 1) {
		become_leaver(member);
	} else if (concurrent > 1) {
		// No quorum, so become a LOSER and resync from the master.
		become_leaver(member);
	} else {
		member_set_status(member, STEP_LEADER);
	}
}

static enum sqlx_action_e
_member_get_next_action (const struct election_member_s *m)
{
	const struct election_manager_s *M = m->manager;

	switch (m->step) {

		case STEP_NONE:
			if (_is_over(m->last_atime, M->delay_expire_none))
				return ACTION_EXPIRE;
			return ACTION_NONE;

		case STEP_CANDREQ:
		case STEP_CANDOK:
		case STEP_LEAVING:
		case STEP_PRELOST:
		case STEP_PRELEAD:
			if (_is_over (m->last_atime, M->delay_expire_pending))
				return ACTION_EXPIRE;
			if (_is_over (m->last_status, M->delay_fail_idle))
				return ACTION_FAIL;
			if (_is_over (m->last_status, M->delay_retry_pending))
				return ACTION_RETRY;
			if (_is_over (m->last_USE, M->delay_ping_pending))
				return ACTION_PING;
			return ACTION_NONE;

		case STEP_LOST:
		case STEP_LEADER:
			if (_is_over (m->last_atime, M->delay_expire_final))
				return ACTION_EXPIRE;
			if (_is_over (m->last_USE, M->delay_ping_final))
				return ACTION_PING;
			return ACTION_NONE;

		case STEP_FAILED:
			if (_is_over (m->last_atime, M->delay_expire_final))
				return ACTION_EXPIRE;
			if (_is_over (m->last_status, M->delay_retry_failed))
				return ACTION_RESTART;
			if (_is_over (m->last_USE, M->delay_ping_failed))
				return ACTION_PING;
			return ACTION_NONE;
	}

	g_assert_not_reached ();
	return ACTION_NONE;
}

static void
_member_react (struct election_member_s *member,
		enum event_type_e evt,
		void *evt_arg)
{
	gchar tag[256];
	GArray *i64v = NULL;
	guint reqid;
	int zrc;

	MEMBER_CHECK(member);
	g_snprintf(tag, sizeof(tag), "EVENT:%s", _evt2str(evt));
	member_debug(__FUNCTION__, tag, member);

	switch (evt) {

		case EVT_DISCONNECTED:
			member_reset(member);
			return member_set_status(member, STEP_FAILED);

		case EVT_RESYNC_DONE:
			EXTRA_ASSERT(evt_arg != NULL);
			reqid = *((guint*)evt_arg);
			if (reqid == member->reqid_PIPEFROM) {
				member->pending_PIPEFROM = 0;
				member->reqid_PIPEFROM = 0;
			}
			break;

		default:
			break;
	}

	switch (member->step) {

		case STEP_NONE:
			EXTRA_ASSERT(member->myid == -1);
			EXTRA_ASSERT(member->master_id == -1);
			EXTRA_ASSERT(member->master_url == NULL);
			EXTRA_ASSERT(member->pending_watch == 0);
			EXTRA_ASSERT(member->pending_PIPEFROM == 0);
			switch (evt) {
				case EVT_NONE:
					member->requested_USE = 0;
					if (member->manager->exiting) {
						member_reset_pending (member);
						return;
					}
					if (!defer_USE(member))
						return member_set_status(member, STEP_FAILED);
					zrc = step_StartElection_start(member);
					if (ZOK != zrc) {
						member_warn_failed_creation(member, zrc);
						return member_set_status(member, STEP_FAILED);
					}
					return member_set_status(member, STEP_CANDREQ);
				case EVT_RESYNC_REQ:
					member->requested_PIPEFROM = 1;
					member->requested_USE = 1;
					return;
				case EVT_EXITING:
					return;
				default:
					GRID_DEBUG("IGNORED");
					return;
			}

		case STEP_CANDREQ:
			EXTRA_ASSERT(member->myid == -1);
			EXTRA_ASSERT(member->master_id == -1);
			EXTRA_ASSERT(member->master_url == NULL);
			EXTRA_ASSERT(member->pending_watch == 0);
			EXTRA_ASSERT(member->pending_PIPEFROM == 0);
			switch (evt) {
				case EVT_NONE:
					return;
				case EVT_RESYNC_REQ:
					member->requested_PIPEFROM = 1;
					return;
				case EVT_EXITING:
					member->requested_EXIT = 1;
					return;
				case EVT_CREATE_OK:
					EXTRA_ASSERT(evt_arg != NULL);
					member_set_id(member, *((gint64*)evt_arg));
					if (ZOK != step_WatchNode_start(member))
						return become_failed (member);
					return become_candidate (member);
				case EVT_CREATE_KO:
					zrc = *((int*)evt_arg);
					member_warn_failed_creation(member, zrc);
					return become_failed(member);
				default:
					GRID_DEBUG("IGNORED");
					return;
			}
			return;

		case STEP_CANDOK:
			//EXTRA_ASSERT(member->myid > 0);
			EXTRA_ASSERT(member->master_id == -1);
			EXTRA_ASSERT(member->master_url == NULL);
			switch (evt) {
				case EVT_NONE:
					return;
				case EVT_RESYNC_REQ:
					member_ask_RESYNC_if_not_pending (member);
					return;
				case EVT_EXITING:
					return become_leaver(member);
				case EVT_LIST_OK:
					i64v = evt_arg;
					EXTRA_ASSERT(i64v != NULL);
					if (!member_in_group(member, i64v)) {
						member_trace(__FUNCTION__, "DISAPPEARED", member);
						return restart_election(member);
					} else {
						if (member_group_master(member, i64v)) {
							member_set_master_id(member, member->myid);
							member_set_status(member, STEP_PRELEAD);
							return defer_GETVERS(member);
						} else {
							member_set_master_id(member, g_array_index(i64v, gint64, 0));
							member_set_status(member, STEP_PRELOST);
							zrc = step_AskMaster_start(member);
							if (zrc != ZOK) {
								GRID_WARN("AskMaster failed [%s.%s] [%s] : (%d) %s",
										member->name.base, member->name.type, hashstr_str(member->key),
										zrc, zerror(zrc));
								return become_leaver(member);
							} else {
								return defer_GETVERS(member);
							}
						}
					}
					g_assert_not_reached ();
					return;
				case EVT_LIST_KO:
				case EVT_NODE_LEFT:
					return become_candidate(member);
				default:
					GRID_DEBUG("IGNORED");
					return;
			}
			return;

		case STEP_PRELOST:
			EXTRA_ASSERT(member->myid != -1);
			EXTRA_ASSERT(member->master_id != -1);
			EXTRA_ASSERT(member->master_id != member->myid);
			//EXTRA_ASSERT(member->master_url == NULL);
			switch (evt) {
				case EVT_NONE:
					return;
				case EVT_RESYNC_REQ:
					return member_ask_RESYNC_if_not_pending(member);
				case EVT_DISCONNECTED:
					return;

				case EVT_CREATE_OK:
				case EVT_CREATE_KO:
				case EVT_LEAVE_OK:
				case EVT_LEAVE_KO:
				case EVT_LIST_OK:
				case EVT_LIST_KO:
					member_warn("ABNORMAL", member);
				case EVT_NODE_LEFT:
				case EVT_MASTER_KO:
				case EVT_MASTER_EMPTY:
				case EVT_MASTER_CHANGE:
					return become_candidate(member);

				case EVT_EXITING:
					return become_leaver(member);

				case EVT_MASTER_OK:
					EXTRA_ASSERT(evt_arg != NULL);
					member_set_master_url(member, (gchar*)evt_arg);
					return member_finish_PRELOST(member);

				case EVT_GETVERS_OK:
					if (member_concerned_by_GETVERS(member, evt_arg))
						member_finish_PRELOST(member);
					return;

				case EVT_GETVERS_OUTDATED:
					if (member_concerned_by_GETVERS(member, evt_arg)) {
						member_ask_RESYNC_if_not_pending(member);
						// No need to finish, the RESYNC itself is a
						// pending action avoiding the finish
					}
					return;

				case EVT_GETVERS_CONCURRENT:
					if (member_concerned_by_GETVERS(member, evt_arg)) {
						++ member->concurrent_GETVERS;
						member_finish_PRELOST(member);
					}
					return;

				case EVT_GETVERS_ERROR:
					if (member_concerned_by_GETVERS(member, evt_arg)) {
						++ member->errors_GETVERS;
						member_finish_PRELOST(member);
					}
					return;

				case EVT_RESYNC_DONE:
					if (!member_has_action(member) && member->master_url)
						member_set_status(member, STEP_LOST);
					return;
			}
			return;

		case STEP_PRELEAD:
			EXTRA_ASSERT(member->myid != -1);
			EXTRA_ASSERT(member->master_id == member->myid);
			EXTRA_ASSERT(member->master_url == NULL);
			switch (evt) {
				case EVT_NONE:
					return;
				case EVT_RESYNC_REQ:
				case EVT_EXITING:
					return become_leaver(member);
				case EVT_DISCONNECTED:
					return;
				case EVT_CREATE_OK:
				case EVT_CREATE_KO:
				case EVT_NODE_LEFT:
				case EVT_MASTER_OK:
				case EVT_MASTER_KO:
				case EVT_LIST_OK:
				case EVT_LIST_KO:
				case EVT_LEAVE_OK:
				case EVT_LEAVE_KO:
				case EVT_MASTER_EMPTY:
				case EVT_MASTER_CHANGE:
				case EVT_RESYNC_DONE:
					return become_candidate(member);

				case EVT_GETVERS_OUTDATED:
					if (member_concerned_by_GETVERS(member, evt_arg))
						become_leaver(member);
					return;

				case EVT_GETVERS_OK:
					if (member_concerned_by_GETVERS(member, evt_arg))
						member_finish_PRELEAD(member);
					return;

				case EVT_GETVERS_CONCURRENT:
					if (member_concerned_by_GETVERS(member, evt_arg)) {
						++ member->concurrent_GETVERS;
						member_finish_PRELEAD(member);
					}
					return;

				case EVT_GETVERS_ERROR:
					if (member_concerned_by_GETVERS(member, evt_arg)) {
						++ member->errors_GETVERS;
						member_finish_PRELEAD(member);
					}
					return;
			}
			return;

		case STEP_LEAVING:
			switch (evt) {
				case EVT_NONE:
					if (!member->manager->exiting)
						member->requested_USE = 1;
					return;
				case EVT_RESYNC_REQ:
					return member_ask_RESYNC_if_not_pending(member);
				case EVT_LEAVE_OK:
					GRID_INFO("LEFT election [%s.%s]", member->name.base, member->name.type);
					member_reset(member);
					return member_set_status(member, STEP_NONE);
				case EVT_LEAVE_KO:
					return become_leaver(member);
				default:
					GRID_DEBUG("IGNORED");
					return;
			}
			return;

		case STEP_LOST:
			EXTRA_ASSERT(member->myid != -1);
			EXTRA_ASSERT(member->master_id != -1);
			EXTRA_ASSERT(member->master_id != member->myid);
			EXTRA_ASSERT(member->master_url != NULL);
			switch (evt) {
				case EVT_NONE:
					return;
				case EVT_EXITING:
					return become_leaver(member);
				case EVT_NODE_LEFT:
					member_warn("DELETED", member);
					return become_leaver(member);
				case EVT_MASTER_KO:
				case EVT_MASTER_EMPTY:
				case EVT_MASTER_CHANGE:
					return become_candidate(member);
				case EVT_RESYNC_REQ:
					member_ask_RESYNC_if_not_pending (member);
					return member_set_status(member, STEP_PRELOST);
				default:
					GRID_DEBUG("IGNORED");
					return;
			}
			return;

		case STEP_LEADER:
			EXTRA_ASSERT(member->myid != -1);
			EXTRA_ASSERT(member->master_id == member->myid);
			EXTRA_ASSERT(member->master_url == NULL);
			switch (evt) {
				case EVT_NONE:
					return;
				case EVT_RESYNC_REQ:
				case EVT_EXITING:
					return become_leaver(member);
				case EVT_NODE_LEFT:
					member_warn("DELETED", member);
					return become_leaver(member);
				default:
					GRID_DEBUG("IGNORED");
					return;
			}
			return;

		case STEP_FAILED:
			switch (evt) {
				case EVT_NONE:
					return;
				case EVT_RESYNC_REQ:
					member_ask_RESYNC_if_not_pending(member);
					return restart_election(member);
				case EVT_CREATE_KO:
				case EVT_NODE_LEFT:
					return member_reset(member);
				default:
					GRID_DEBUG("IGNORED");
					return;
			}
			return;
	}
}

static void
_member_play_timer (struct election_member_s *member,
		enum sqlx_action_e action)
{
	switch (action) {
		case ACTION_NONE:
			return;
		case ACTION_PING:
			GRID_TRACE("PING!");
			return (void) defer_USE (member);
		case ACTION_FAIL:
			GRID_TRACE("FAIL!");
			return member_set_status (member, STEP_FAILED);
		case ACTION_RETRY:
			GRID_TRACE("RETRY!");
			defer_GETVERS (member);
			member->last_status = oio_ext_monotonic_time ();
			return;
		case ACTION_RESTART:
			GRID_TRACE("RESTART!");
			return restart_election (member);
		case ACTION_EXPIRE:
			GRID_TRACE("EXPIRE!");
			return;
	}
}

static void
transition(struct election_member_s *member, enum event_type_e evt,
		void *evt_arg)
{
	enum election_step_e pre = member->step;
	_member_react(member, evt, evt_arg);
	enum election_step_e post = member->step;
	if (evt != EVT_NONE || pre != post)
		member_log_event(member, pre, evt);

	if (member->requested_PIPEFROM && member->step == STEP_PRELOST && member->master_url)
		defer_PIPEFROM(member);
	if (member->requested_USE && (member->step == STEP_NONE))
		restart_election(member);

	return _member_play_timer (member, _member_get_next_action (member));
}

static void
transition_error(struct election_member_s *member,
		enum event_type_e evt, enum ZOO_ERRORS zrc)
{
	EXTRA_ASSERT(zrc <= ZSYSTEMERROR || zrc <= ZAPIERROR);
	if (zrc < ZAPIERROR)
		return transition(member, evt, &zrc);
	if (zrc < ZSYSTEMERROR)
		return transition(member, EVT_DISCONNECTED, &zrc);
	g_assert_not_reached();
}

gboolean
election_manager_play_timers (struct election_manager_s *m)
{
	gboolean rc = FALSE;
	struct hashstr_s *k = NULL;
	struct election_member_s *member = NULL;

	g_mutex_lock (&m->lock);
	if (lru_tree_get_first (m->lrutree_members, (void**)&k, (void**)&member)) {
		enum sqlx_action_e action = _member_get_next_action (member);
		GRID_DEBUG("[%s] action [%s] refcount %u", hashstr_str(member->key),
				_action2str(action), member->refcount);
		if (action == ACTION_EXPIRE) {
			if (member->refcount == 1) { /* 1 for the lrutree_members */
				rc = TRUE;
				lru_tree_remove (m->lrutree_members, member->key);
				member_unref (member);
				member_destroy (member);
			}
		} else if (action != ACTION_NONE) {
			rc = TRUE;
			_member_play_timer (member, action);
		}
	}
	g_mutex_unlock (&m->lock);

	return rc;
}
